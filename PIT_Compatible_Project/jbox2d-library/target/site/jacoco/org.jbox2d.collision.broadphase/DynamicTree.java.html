<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DynamicTree.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jbox2d-library</a> &gt; <a href="index.source.html" class="el_package">org.jbox2d.collision.broadphase</a> &gt; <span class="el_source">DynamicTree.java</span></div><h1>DynamicTree.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2013, Daniel Murphy
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************/
package org.jbox2d.collision.broadphase;

import org.jbox2d.callbacks.DebugDraw;
import org.jbox2d.callbacks.TreeCallback;
import org.jbox2d.callbacks.TreeRayCastCallback;
import org.jbox2d.collision.AABB;
import org.jbox2d.collision.RayCastInput;
import org.jbox2d.common.Color3f;
import org.jbox2d.common.MathUtils;
import org.jbox2d.common.Settings;
import org.jbox2d.common.Vec2;

/**
 * A dynamic tree arranges data in a binary tree to accelerate queries such as volume queries and
 * ray casts. Leafs are proxies with an AABB. In the tree we expand the proxy AABB by _fatAABBFactor
 * so that the proxy AABB is bigger than the client object. This allows the client object to move by
 * small amounts without triggering a tree update.
 * 
 * @author daniel
 */
<span class="nc bnc" id="L44" title="All 2 branches missed.">public class DynamicTree implements BroadPhaseStrategy {</span>
  public static final int MAX_STACK_SIZE = 64;
  public static final int NULL_NODE = -1;

  private DynamicTreeNode m_root;
  private DynamicTreeNode[] m_nodes;
  private int m_nodeCount;
  private int m_nodeCapacity;

  private int m_freeList;

  private int m_insertionCount;

<span class="nc" id="L57">  private final Vec2[] drawVecs = new Vec2[4];</span>
<span class="nc" id="L58">  private final TreeNodeStack nodeStack = new TreeNodeStack(10);</span>

<span class="nc" id="L60">  public DynamicTree() {</span>
<span class="nc" id="L61">    m_root = null;</span>
<span class="nc" id="L62">    m_nodeCount = 0;</span>
<span class="nc" id="L63">    m_nodeCapacity = 16;</span>
<span class="nc" id="L64">    m_nodes = new DynamicTreeNode[16];</span>

    // Build a linked list for the free list.
<span class="nc bnc" id="L67" title="All 2 branches missed.">    for (int i = m_nodeCapacity - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L68">      m_nodes[i] = new DynamicTreeNode(i);</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">      m_nodes[i].parent = (i == m_nodeCapacity - 1) ? null : m_nodes[i + 1];</span>
<span class="nc" id="L70">      m_nodes[i].height = -1;</span>
    }
<span class="nc" id="L72">    m_freeList = 0;</span>

<span class="nc" id="L74">    m_insertionCount = 0;</span>

<span class="nc bnc" id="L76" title="All 2 branches missed.">    for (int i = 0; i &lt; drawVecs.length; i++) {</span>
<span class="nc" id="L77">      drawVecs[i] = new Vec2();</span>
    }
<span class="nc" id="L79">  }</span>

  @Override
  public final int createProxy(final AABB aabb, Object userData) {
<span class="nc" id="L83">    final DynamicTreeNode node = allocateNode();</span>
<span class="nc" id="L84">    int proxyId = node.id;</span>
    // Fatten the aabb
<span class="nc" id="L86">    final AABB nodeAABB = node.aabb;</span>
<span class="nc" id="L87">    nodeAABB.lowerBound.x = aabb.lowerBound.x - Settings.aabbExtension;</span>
<span class="nc" id="L88">    nodeAABB.lowerBound.y = aabb.lowerBound.y - Settings.aabbExtension;</span>
<span class="nc" id="L89">    nodeAABB.upperBound.x = aabb.upperBound.x + Settings.aabbExtension;</span>
<span class="nc" id="L90">    nodeAABB.upperBound.y = aabb.upperBound.y + Settings.aabbExtension;</span>
<span class="nc" id="L91">    node.userData = userData;</span>

<span class="nc" id="L93">    insertLeaf(proxyId);</span>

<span class="nc" id="L95">    return proxyId;</span>
  }

  @Override
  public final void destroyProxy(int proxyId) {
<span class="nc bnc" id="L100" title="All 6 branches missed.">    assert (0 &lt;= proxyId &amp;&amp; proxyId &lt; m_nodeCapacity);</span>
<span class="nc" id="L101">    DynamicTreeNode node = m_nodes[proxyId];</span>
<span class="nc bnc" id="L102" title="All 4 branches missed.">    assert (node.isLeaf());</span>

<span class="nc" id="L104">    removeLeaf(node);</span>
<span class="nc" id="L105">    freeNode(node);</span>
<span class="nc" id="L106">  }</span>

  @Override
  public final boolean moveProxy(int proxyId, final AABB aabb, Vec2 displacement) {
<span class="nc bnc" id="L110" title="All 6 branches missed.">    assert (0 &lt;= proxyId &amp;&amp; proxyId &lt; m_nodeCapacity);</span>
<span class="nc" id="L111">    final DynamicTreeNode node = m_nodes[proxyId];</span>
<span class="nc bnc" id="L112" title="All 4 branches missed.">    assert (node.isLeaf());</span>

<span class="nc" id="L114">    final AABB nodeAABB = node.aabb;</span>
    // if (nodeAABB.contains(aabb)) {
<span class="nc bnc" id="L116" title="All 8 branches missed.">    if (nodeAABB.lowerBound.x &gt; aabb.lowerBound.x &amp;&amp; nodeAABB.lowerBound.y &gt; aabb.lowerBound.y</span>
        &amp;&amp; aabb.upperBound.x &gt; nodeAABB.upperBound.x &amp;&amp; aabb.upperBound.y &gt; nodeAABB.upperBound.y) {
<span class="nc" id="L118">      return false;</span>
    }

<span class="nc" id="L121">    removeLeaf(node);</span>

    // Extend AABB
<span class="nc" id="L124">    final Vec2 lowerBound = nodeAABB.lowerBound;</span>
<span class="nc" id="L125">    final Vec2 upperBound = nodeAABB.upperBound;</span>
<span class="nc" id="L126">    lowerBound.x = aabb.lowerBound.x - Settings.aabbExtension;</span>
<span class="nc" id="L127">    lowerBound.y = aabb.lowerBound.y - Settings.aabbExtension;</span>
<span class="nc" id="L128">    upperBound.x = aabb.upperBound.x + Settings.aabbExtension;</span>
<span class="nc" id="L129">    upperBound.y = aabb.upperBound.y + Settings.aabbExtension;</span>

    // Predict AABB displacement.
<span class="nc" id="L132">    final float dx = displacement.x * Settings.aabbMultiplier;</span>
<span class="nc" id="L133">    final float dy = displacement.y * Settings.aabbMultiplier;</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">    if (dx &lt; 0.0f) {</span>
<span class="nc" id="L135">      lowerBound.x += dx;</span>
    } else {
<span class="nc" id="L137">      upperBound.x += dx;</span>
    }

<span class="nc bnc" id="L140" title="All 2 branches missed.">    if (dy &lt; 0.0f) {</span>
<span class="nc" id="L141">      lowerBound.y += dy;</span>
    } else {
<span class="nc" id="L143">      upperBound.y += dy;</span>
    }

<span class="nc" id="L146">    insertLeaf(proxyId);</span>
<span class="nc" id="L147">    return true;</span>
  }

  @Override
  public final Object getUserData(int proxyId) {
<span class="nc bnc" id="L152" title="All 6 branches missed.">    assert (0 &lt;= proxyId &amp;&amp; proxyId &lt; m_nodeCapacity);</span>
<span class="nc" id="L153">    return m_nodes[proxyId].userData;</span>
  }

  @Override
  public final AABB getFatAABB(int proxyId) {
<span class="nc bnc" id="L158" title="All 6 branches missed.">    assert (0 &lt;= proxyId &amp;&amp; proxyId &lt; m_nodeCapacity);</span>
<span class="nc" id="L159">    return m_nodes[proxyId].aabb;</span>
  }

  @Override
  public final void query(TreeCallback callback, AABB aabb) {
<span class="nc" id="L164">    nodeStack.reset();</span>
<span class="nc" id="L165">    nodeStack.push(m_root);</span>

<span class="nc bnc" id="L167" title="All 2 branches missed.">    while (nodeStack.getCount() &gt; 0) {</span>
<span class="nc" id="L168">      DynamicTreeNode node = nodeStack.pop();</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">      if (node == null) {</span>
<span class="nc" id="L170">        continue;</span>
      }

<span class="nc bnc" id="L173" title="All 2 branches missed.">      if (AABB.testOverlap(node.aabb, aabb)) {</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">        if (node.child1 == null) {</span>
<span class="nc" id="L175">          boolean proceed = callback.treeCallback(node.id);</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">          if (!proceed) {</span>
<span class="nc" id="L177">            return;</span>
          }
<span class="nc" id="L179">        } else {</span>
<span class="nc" id="L180">          nodeStack.push(node.child1);</span>
<span class="nc" id="L181">          nodeStack.push(node.child2);</span>
        }
      }
<span class="nc" id="L184">    }</span>
<span class="nc" id="L185">  }</span>

<span class="nc" id="L187">  private final Vec2 r = new Vec2();</span>
<span class="nc" id="L188">  private final AABB aabb = new AABB();</span>
<span class="nc" id="L189">  private final RayCastInput subInput = new RayCastInput();</span>

  @Override
  public void raycast(TreeRayCastCallback callback, RayCastInput input) {
<span class="nc" id="L193">    final Vec2 p1 = input.p1;</span>
<span class="nc" id="L194">    final Vec2 p2 = input.p2;</span>
<span class="nc" id="L195">    float p1x = p1.x, p2x = p2.x, p1y = p1.y, p2y = p2.y;</span>
    float vx, vy;
    float rx, ry;
    float absVx, absVy;
    float cx, cy;
    float hx, hy;
    float tempx, tempy;
<span class="nc" id="L202">    r.x = p2x - p1x;</span>
<span class="nc" id="L203">    r.y = p2y - p1y;</span>
<span class="nc bnc" id="L204" title="All 4 branches missed.">    assert ((r.x * r.x + r.y * r.y) &gt; 0f);</span>
<span class="nc" id="L205">    r.normalize();</span>
<span class="nc" id="L206">    rx = r.x;</span>
<span class="nc" id="L207">    ry = r.y;</span>

    // v is perpendicular to the segment.
<span class="nc" id="L210">    vx = -1f * ry;</span>
<span class="nc" id="L211">    vy = 1f * rx;</span>
<span class="nc" id="L212">    absVx = MathUtils.abs(vx);</span>
<span class="nc" id="L213">    absVy = MathUtils.abs(vy);</span>

    // Separating axis for segment (Gino, p80).
    // |dot(v, p1 - c)| &gt; dot(|v|, h)

<span class="nc" id="L218">    float maxFraction = input.maxFraction;</span>

    // Build a bounding box for the segment.
<span class="nc" id="L221">    final AABB segAABB = aabb;</span>
    // Vec2 t = p1 + maxFraction * (p2 - p1);
    // before inline
    // temp.set(p2).subLocal(p1).mulLocal(maxFraction).addLocal(p1);
    // Vec2.minToOut(p1, temp, segAABB.lowerBound);
    // Vec2.maxToOut(p1, temp, segAABB.upperBound);
<span class="nc" id="L227">    tempx = (p2x - p1x) * maxFraction + p1x;</span>
<span class="nc" id="L228">    tempy = (p2y - p1y) * maxFraction + p1y;</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">    segAABB.lowerBound.x = p1x &lt; tempx ? p1x : tempx;</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">    segAABB.lowerBound.y = p1y &lt; tempy ? p1y : tempy;</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">    segAABB.upperBound.x = p1x &gt; tempx ? p1x : tempx;</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">    segAABB.upperBound.y = p1y &gt; tempy ? p1y : tempy;</span>
    // end inline

<span class="nc" id="L235">    nodeStack.reset();</span>
<span class="nc" id="L236">    nodeStack.push(m_root);</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">    while (nodeStack.getCount() &gt; 0) {</span>
<span class="nc" id="L238">      final DynamicTreeNode node = nodeStack.pop();</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">      if (node == null) {</span>
<span class="nc" id="L240">        continue;</span>
      }

<span class="nc" id="L243">      final AABB nodeAABB = node.aabb;</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">      if (!AABB.testOverlap(nodeAABB, segAABB)) {</span>
<span class="nc" id="L245">        continue;</span>
      }

      // Separating axis for segment (Gino, p80).
      // |dot(v, p1 - c)| &gt; dot(|v|, h)
      // node.aabb.getCenterToOut(c);
      // node.aabb.getExtentsToOut(h);
<span class="nc" id="L252">      cx = (nodeAABB.lowerBound.x + nodeAABB.upperBound.x) * .5f;</span>
<span class="nc" id="L253">      cy = (nodeAABB.lowerBound.y + nodeAABB.upperBound.y) * .5f;</span>
<span class="nc" id="L254">      hx = (nodeAABB.upperBound.x - nodeAABB.lowerBound.x) * .5f;</span>
<span class="nc" id="L255">      hy = (nodeAABB.upperBound.y - nodeAABB.lowerBound.y) * .5f;</span>
<span class="nc" id="L256">      tempx = p1x - cx;</span>
<span class="nc" id="L257">      tempy = p1y - cy;</span>
<span class="nc" id="L258">      float separation = MathUtils.abs(vx * tempx + vy * tempy) - (absVx * hx + absVy * hy);</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">      if (separation &gt; 0.0f) {</span>
<span class="nc" id="L260">        continue;</span>
      }

<span class="nc bnc" id="L263" title="All 2 branches missed.">      if (node.isLeaf()) {</span>
<span class="nc" id="L264">        subInput.p1.x = p1x;</span>
<span class="nc" id="L265">        subInput.p1.y = p1y;</span>
<span class="nc" id="L266">        subInput.p2.x = p2x;</span>
<span class="nc" id="L267">        subInput.p2.y = p2y;</span>
<span class="nc" id="L268">        subInput.maxFraction = maxFraction;</span>

<span class="nc" id="L270">        float value = callback.raycastCallback(subInput, node.id);</span>

<span class="nc bnc" id="L272" title="All 2 branches missed.">        if (value == 0.0f) {</span>
          // The client has terminated the ray cast.
<span class="nc" id="L274">          return;</span>
        }

<span class="nc bnc" id="L277" title="All 2 branches missed.">        if (value &gt; 0.0f) {</span>
          // Update segment bounding box.
<span class="nc" id="L279">          maxFraction = value;</span>
          // temp.set(p2).subLocal(p1).mulLocal(maxFraction).addLocal(p1);
          // Vec2.minToOut(p1, temp, segAABB.lowerBound);
          // Vec2.maxToOut(p1, temp, segAABB.upperBound);
<span class="nc" id="L283">          tempx = (p2x - p1x) * maxFraction + p1x;</span>
<span class="nc" id="L284">          tempy = (p2y - p1y) * maxFraction + p1y;</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">          segAABB.lowerBound.x = p1x &lt; tempx ? p1x : tempx;</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">          segAABB.lowerBound.y = p1y &lt; tempy ? p1y : tempy;</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">          segAABB.upperBound.x = p1x &gt; tempx ? p1x : tempx;</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">          segAABB.upperBound.y = p1y &gt; tempy ? p1y : tempy;</span>
        }
<span class="nc" id="L290">      } else {</span>
<span class="nc" id="L291">        nodeStack.push(node.child1);</span>
<span class="nc" id="L292">        nodeStack.push(node.child2);</span>
      }
<span class="nc" id="L294">    }</span>
<span class="nc" id="L295">  }</span>

  @Override
  public final int computeHeight() {
<span class="nc" id="L299">    return computeHeight(m_root);</span>
  }

  private final int computeHeight(DynamicTreeNode node) {
<span class="nc bnc" id="L303" title="All 6 branches missed.">    assert (0 &lt;= node.id &amp;&amp; node.id &lt; m_nodeCapacity);</span>

<span class="nc bnc" id="L305" title="All 2 branches missed.">    if (node.isLeaf()) {</span>
<span class="nc" id="L306">      return 0;</span>
    }
<span class="nc" id="L308">    int height1 = computeHeight(node.child1);</span>
<span class="nc" id="L309">    int height2 = computeHeight(node.child2);</span>
<span class="nc" id="L310">    return 1 + MathUtils.max(height1, height2);</span>
  }

  /**
   * Validate this tree. For testing.
   */
  public void validate() {
<span class="nc" id="L317">    validateStructure(m_root);</span>
<span class="nc" id="L318">    validateMetrics(m_root);</span>

<span class="nc" id="L320">    int freeCount = 0;</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">    DynamicTreeNode freeNode = m_freeList != NULL_NODE ? m_nodes[m_freeList] : null;</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">    while (freeNode != null) {</span>
<span class="nc bnc" id="L323" title="All 6 branches missed.">      assert (0 &lt;= freeNode.id &amp;&amp; freeNode.id &lt; m_nodeCapacity);</span>
<span class="nc bnc" id="L324" title="All 4 branches missed.">      assert (freeNode == m_nodes[freeNode.id]);</span>
<span class="nc" id="L325">      freeNode = freeNode.parent;</span>
<span class="nc" id="L326">      ++freeCount;</span>
    }

<span class="nc bnc" id="L329" title="All 4 branches missed.">    assert (getHeight() == computeHeight());</span>

<span class="nc bnc" id="L331" title="All 4 branches missed.">    assert (m_nodeCount + freeCount == m_nodeCapacity);</span>
<span class="nc" id="L332">  }</span>

  @Override
  public int getHeight() {
<span class="nc bnc" id="L336" title="All 2 branches missed.">    if (m_root == null) {</span>
<span class="nc" id="L337">      return 0;</span>
    }
<span class="nc" id="L339">    return m_root.height;</span>
  }

  @Override
  public int getMaxBalance() {
<span class="nc" id="L344">    int maxBalance = 0;</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">    for (int i = 0; i &lt; m_nodeCapacity; ++i) {</span>
<span class="nc" id="L346">      final DynamicTreeNode node = m_nodes[i];</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">      if (node.height &lt;= 1) {</span>
<span class="nc" id="L348">        continue;</span>
      }

<span class="nc bnc" id="L351" title="All 4 branches missed.">      assert (node.isLeaf() == false);</span>

<span class="nc" id="L353">      DynamicTreeNode child1 = node.child1;</span>
<span class="nc" id="L354">      DynamicTreeNode child2 = node.child2;</span>
<span class="nc" id="L355">      int balance = MathUtils.abs(child2.height - child1.height);</span>
<span class="nc" id="L356">      maxBalance = MathUtils.max(maxBalance, balance);</span>
    }

<span class="nc" id="L359">    return maxBalance;</span>
  }

  @Override
  public float getAreaRatio() {
<span class="nc bnc" id="L364" title="All 2 branches missed.">    if (m_root == null) {</span>
<span class="nc" id="L365">      return 0.0f;</span>
    }

<span class="nc" id="L368">    final DynamicTreeNode root = m_root;</span>
<span class="nc" id="L369">    float rootArea = root.aabb.getPerimeter();</span>

<span class="nc" id="L371">    float totalArea = 0.0f;</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">    for (int i = 0; i &lt; m_nodeCapacity; ++i) {</span>
<span class="nc" id="L373">      final DynamicTreeNode node = m_nodes[i];</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">      if (node.height &lt; 0) {</span>
        // Free node in pool
<span class="nc" id="L376">        continue;</span>
      }

<span class="nc" id="L379">      totalArea += node.aabb.getPerimeter();</span>
    }

<span class="nc" id="L382">    return totalArea / rootArea;</span>
  }

  /**
   * Build an optimal tree. Very expensive. For testing.
   */
  public void rebuildBottomUp() {
<span class="nc" id="L389">    int[] nodes = new int[m_nodeCount];</span>
<span class="nc" id="L390">    int count = 0;</span>

    // Build array of leaves. Free the rest.
<span class="nc bnc" id="L393" title="All 2 branches missed.">    for (int i = 0; i &lt; m_nodeCapacity; ++i) {</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">      if (m_nodes[i].height &lt; 0) {</span>
        // free node in pool
<span class="nc" id="L396">        continue;</span>
      }

<span class="nc" id="L399">      DynamicTreeNode node = m_nodes[i];</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">      if (node.isLeaf()) {</span>
<span class="nc" id="L401">        node.parent = null;</span>
<span class="nc" id="L402">        nodes[count] = i;</span>
<span class="nc" id="L403">        ++count;</span>
      } else {
<span class="nc" id="L405">        freeNode(node);</span>
      }
    }

<span class="nc" id="L409">    AABB b = new AABB();</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">    while (count &gt; 1) {</span>
<span class="nc" id="L411">      float minCost = Float.MAX_VALUE;</span>
<span class="nc" id="L412">      int iMin = -1, jMin = -1;</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">      for (int i = 0; i &lt; count; ++i) {</span>
<span class="nc" id="L414">        AABB aabbi = m_nodes[nodes[i]].aabb;</span>

<span class="nc bnc" id="L416" title="All 2 branches missed.">        for (int j = i + 1; j &lt; count; ++j) {</span>
<span class="nc" id="L417">          AABB aabbj = m_nodes[nodes[j]].aabb;</span>
<span class="nc" id="L418">          b.combine(aabbi, aabbj);</span>
<span class="nc" id="L419">          float cost = b.getPerimeter();</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">          if (cost &lt; minCost) {</span>
<span class="nc" id="L421">            iMin = i;</span>
<span class="nc" id="L422">            jMin = j;</span>
<span class="nc" id="L423">            minCost = cost;</span>
          }
        }
      }

<span class="nc" id="L428">      int index1 = nodes[iMin];</span>
<span class="nc" id="L429">      int index2 = nodes[jMin];</span>
<span class="nc" id="L430">      DynamicTreeNode child1 = m_nodes[index1];</span>
<span class="nc" id="L431">      DynamicTreeNode child2 = m_nodes[index2];</span>

<span class="nc" id="L433">      DynamicTreeNode parent = allocateNode();</span>
<span class="nc" id="L434">      parent.child1 = child1;</span>
<span class="nc" id="L435">      parent.child2 = child2;</span>
<span class="nc" id="L436">      parent.height = 1 + MathUtils.max(child1.height, child2.height);</span>
<span class="nc" id="L437">      parent.aabb.combine(child1.aabb, child2.aabb);</span>
<span class="nc" id="L438">      parent.parent = null;</span>

<span class="nc" id="L440">      child1.parent = parent;</span>
<span class="nc" id="L441">      child2.parent = parent;</span>

<span class="nc" id="L443">      nodes[jMin] = nodes[count - 1];</span>
<span class="nc" id="L444">      nodes[iMin] = parent.id;</span>
<span class="nc" id="L445">      --count;</span>
<span class="nc" id="L446">    }</span>

<span class="nc" id="L448">    m_root = m_nodes[nodes[0]];</span>

<span class="nc" id="L450">    validate();</span>
<span class="nc" id="L451">  }</span>

  private final DynamicTreeNode allocateNode() {
<span class="nc bnc" id="L454" title="All 2 branches missed.">    if (m_freeList == NULL_NODE) {</span>
<span class="nc bnc" id="L455" title="All 4 branches missed.">      assert (m_nodeCount == m_nodeCapacity);</span>

<span class="nc" id="L457">      DynamicTreeNode[] old = m_nodes;</span>
<span class="nc" id="L458">      m_nodeCapacity *= 2;</span>
<span class="nc" id="L459">      m_nodes = new DynamicTreeNode[m_nodeCapacity];</span>
<span class="nc" id="L460">      System.arraycopy(old, 0, m_nodes, 0, old.length);</span>

      // Build a linked list for the free list.
<span class="nc bnc" id="L463" title="All 2 branches missed.">      for (int i = m_nodeCapacity - 1; i &gt;= m_nodeCount; i--) {</span>
<span class="nc" id="L464">        m_nodes[i] = new DynamicTreeNode(i);</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">        m_nodes[i].parent = (i == m_nodeCapacity - 1) ? null : m_nodes[i + 1];</span>
<span class="nc" id="L466">        m_nodes[i].height = -1;</span>
      }
<span class="nc" id="L468">      m_freeList = m_nodeCount;</span>
    }
<span class="nc" id="L470">    int nodeId = m_freeList;</span>
<span class="nc" id="L471">    final DynamicTreeNode treeNode = m_nodes[nodeId];</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">    m_freeList = treeNode.parent != null ? treeNode.parent.id : NULL_NODE;</span>

<span class="nc" id="L474">    treeNode.parent = null;</span>
<span class="nc" id="L475">    treeNode.child1 = null;</span>
<span class="nc" id="L476">    treeNode.child2 = null;</span>
<span class="nc" id="L477">    treeNode.height = 0;</span>
<span class="nc" id="L478">    treeNode.userData = null;</span>
<span class="nc" id="L479">    ++m_nodeCount;</span>
<span class="nc" id="L480">    return treeNode;</span>
  }

  /**
   * returns a node to the pool
   */
  private final void freeNode(DynamicTreeNode node) {
<span class="nc bnc" id="L487" title="All 4 branches missed.">    assert (node != null);</span>
<span class="nc bnc" id="L488" title="All 4 branches missed.">    assert (0 &lt; m_nodeCount);</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">    node.parent = m_freeList != NULL_NODE ? m_nodes[m_freeList] : null;</span>
<span class="nc" id="L490">    node.height = -1;</span>
<span class="nc" id="L491">    m_freeList = node.id;</span>
<span class="nc" id="L492">    m_nodeCount--;</span>
<span class="nc" id="L493">  }</span>

  @Override
  public int getInsertionCount() {
<span class="nc" id="L497">    return m_insertionCount;</span>
  }

<span class="nc" id="L500">  private final AABB combinedAABB = new AABB();</span>

  private final void insertLeaf(int leaf_index) {
<span class="nc" id="L503">    m_insertionCount++;</span>

<span class="nc" id="L505">    DynamicTreeNode leaf = m_nodes[leaf_index];</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">    if (m_root == null) {</span>
<span class="nc" id="L507">      m_root = leaf;</span>
<span class="nc" id="L508">      m_root.parent = null;</span>
<span class="nc" id="L509">      return;</span>
    }

    // find the best sibling
<span class="nc" id="L513">    AABB leafAABB = leaf.aabb;</span>
<span class="nc" id="L514">    DynamicTreeNode index = m_root;</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">    while (index.child1 != null) {</span>
<span class="nc" id="L516">      final DynamicTreeNode node = index;</span>
<span class="nc" id="L517">      DynamicTreeNode child1 = node.child1;</span>
<span class="nc" id="L518">      DynamicTreeNode child2 = node.child2;</span>

<span class="nc" id="L520">      float area = node.aabb.getPerimeter();</span>

<span class="nc" id="L522">      combinedAABB.combine(node.aabb, leafAABB);</span>
<span class="nc" id="L523">      float combinedArea = combinedAABB.getPerimeter();</span>

      // Cost of creating a new parent for this node and the new leaf
<span class="nc" id="L526">      float cost = 2.0f * combinedArea;</span>

      // Minimum cost of pushing the leaf further down the tree
<span class="nc" id="L529">      float inheritanceCost = 2.0f * (combinedArea - area);</span>

      // Cost of descending into child1
      float cost1;
<span class="nc bnc" id="L533" title="All 2 branches missed.">      if (child1.isLeaf()) {</span>
<span class="nc" id="L534">        combinedAABB.combine(leafAABB, child1.aabb);</span>
<span class="nc" id="L535">        cost1 = combinedAABB.getPerimeter() + inheritanceCost;</span>
      } else {
<span class="nc" id="L537">        combinedAABB.combine(leafAABB, child1.aabb);</span>
<span class="nc" id="L538">        float oldArea = child1.aabb.getPerimeter();</span>
<span class="nc" id="L539">        float newArea = combinedAABB.getPerimeter();</span>
<span class="nc" id="L540">        cost1 = (newArea - oldArea) + inheritanceCost;</span>
      }

      // Cost of descending into child2
      float cost2;
<span class="nc bnc" id="L545" title="All 2 branches missed.">      if (child2.isLeaf()) {</span>
<span class="nc" id="L546">        combinedAABB.combine(leafAABB, child2.aabb);</span>
<span class="nc" id="L547">        cost2 = combinedAABB.getPerimeter() + inheritanceCost;</span>
      } else {
<span class="nc" id="L549">        combinedAABB.combine(leafAABB, child2.aabb);</span>
<span class="nc" id="L550">        float oldArea = child2.aabb.getPerimeter();</span>
<span class="nc" id="L551">        float newArea = combinedAABB.getPerimeter();</span>
<span class="nc" id="L552">        cost2 = newArea - oldArea + inheritanceCost;</span>
      }

      // Descend according to the minimum cost.
<span class="nc bnc" id="L556" title="All 4 branches missed.">      if (cost &lt; cost1 &amp;&amp; cost &lt; cost2) {</span>
<span class="nc" id="L557">        break;</span>
      }

      // Descend
<span class="nc bnc" id="L561" title="All 2 branches missed.">      if (cost1 &lt; cost2) {</span>
<span class="nc" id="L562">        index = child1;</span>
      } else {
<span class="nc" id="L564">        index = child2;</span>
      }
<span class="nc" id="L566">    }</span>

<span class="nc" id="L568">    DynamicTreeNode sibling = index;</span>
<span class="nc" id="L569">    DynamicTreeNode oldParent = m_nodes[sibling.id].parent;</span>
<span class="nc" id="L570">    final DynamicTreeNode newParent = allocateNode();</span>
<span class="nc" id="L571">    newParent.parent = oldParent;</span>
<span class="nc" id="L572">    newParent.userData = null;</span>
<span class="nc" id="L573">    newParent.aabb.combine(leafAABB, sibling.aabb);</span>
<span class="nc" id="L574">    newParent.height = sibling.height + 1;</span>

<span class="nc bnc" id="L576" title="All 2 branches missed.">    if (oldParent != null) {</span>
      // The sibling was not the root.
<span class="nc bnc" id="L578" title="All 2 branches missed.">      if (oldParent.child1 == sibling) {</span>
<span class="nc" id="L579">        oldParent.child1 = newParent;</span>
      } else {
<span class="nc" id="L581">        oldParent.child2 = newParent;</span>
      }

<span class="nc" id="L584">      newParent.child1 = sibling;</span>
<span class="nc" id="L585">      newParent.child2 = leaf;</span>
<span class="nc" id="L586">      sibling.parent = newParent;</span>
<span class="nc" id="L587">      leaf.parent = newParent;</span>
    } else {
      // The sibling was the root.
<span class="nc" id="L590">      newParent.child1 = sibling;</span>
<span class="nc" id="L591">      newParent.child2 = leaf;</span>
<span class="nc" id="L592">      sibling.parent = newParent;</span>
<span class="nc" id="L593">      leaf.parent = newParent;</span>
<span class="nc" id="L594">      m_root = newParent;</span>
    }

    // Walk back up the tree fixing heights and AABBs
<span class="nc" id="L598">    index = leaf.parent;</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">    while (index != null) {</span>
<span class="nc" id="L600">      index = balance(index);</span>

<span class="nc" id="L602">      DynamicTreeNode child1 = index.child1;</span>
<span class="nc" id="L603">      DynamicTreeNode child2 = index.child2;</span>

<span class="nc bnc" id="L605" title="All 4 branches missed.">      assert (child1 != null);</span>
<span class="nc bnc" id="L606" title="All 4 branches missed.">      assert (child2 != null);</span>

<span class="nc" id="L608">      index.height = 1 + MathUtils.max(child1.height, child2.height);</span>
<span class="nc" id="L609">      index.aabb.combine(child1.aabb, child2.aabb);</span>

<span class="nc" id="L611">      index = index.parent;</span>
<span class="nc" id="L612">    }</span>

    // validate();
<span class="nc" id="L615">  }</span>

  private final void removeLeaf(DynamicTreeNode leaf) {
<span class="nc bnc" id="L618" title="All 2 branches missed.">    if (leaf == m_root) {</span>
<span class="nc" id="L619">      m_root = null;</span>
<span class="nc" id="L620">      return;</span>
    }

<span class="nc" id="L623">    DynamicTreeNode parent = leaf.parent;</span>
<span class="nc" id="L624">    DynamicTreeNode grandParent = parent.parent;</span>
    DynamicTreeNode sibling;
<span class="nc bnc" id="L626" title="All 2 branches missed.">    if (parent.child1 == leaf) {</span>
<span class="nc" id="L627">      sibling = parent.child2;</span>
    } else {
<span class="nc" id="L629">      sibling = parent.child1;</span>
    }

<span class="nc bnc" id="L632" title="All 2 branches missed.">    if (grandParent != null) {</span>
      // Destroy parent and connect sibling to grandParent.
<span class="nc bnc" id="L634" title="All 2 branches missed.">      if (grandParent.child1 == parent) {</span>
<span class="nc" id="L635">        grandParent.child1 = sibling;</span>
      } else {
<span class="nc" id="L637">        grandParent.child2 = sibling;</span>
      }
<span class="nc" id="L639">      sibling.parent = grandParent;</span>
<span class="nc" id="L640">      freeNode(parent);</span>

      // Adjust ancestor bounds.
<span class="nc" id="L643">      DynamicTreeNode index = grandParent;</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">      while (index != null) {</span>
<span class="nc" id="L645">        index = balance(index);</span>

<span class="nc" id="L647">        DynamicTreeNode child1 = index.child1;</span>
<span class="nc" id="L648">        DynamicTreeNode child2 = index.child2;</span>

<span class="nc" id="L650">        index.aabb.combine(child1.aabb, child2.aabb);</span>
<span class="nc" id="L651">        index.height = 1 + MathUtils.max(child1.height, child2.height);</span>

<span class="nc" id="L653">        index = index.parent;</span>
<span class="nc" id="L654">      }</span>
<span class="nc" id="L655">    } else {</span>
<span class="nc" id="L656">      m_root = sibling;</span>
<span class="nc" id="L657">      sibling.parent = null;</span>
<span class="nc" id="L658">      freeNode(parent);</span>
    }

    // validate();
<span class="nc" id="L662">  }</span>

  // Perform a left or right rotation if node A is imbalanced.
  // Returns the new root index.
  private DynamicTreeNode balance(DynamicTreeNode iA) {
<span class="nc bnc" id="L667" title="All 4 branches missed.">    assert (iA != null);</span>

<span class="nc" id="L669">    DynamicTreeNode A = iA;</span>
<span class="nc bnc" id="L670" title="All 4 branches missed.">    if (A.isLeaf() || A.height &lt; 2) {</span>
<span class="nc" id="L671">      return iA;</span>
    }

<span class="nc" id="L674">    DynamicTreeNode iB = A.child1;</span>
<span class="nc" id="L675">    DynamicTreeNode iC = A.child2;</span>
<span class="nc bnc" id="L676" title="All 6 branches missed.">    assert (0 &lt;= iB.id &amp;&amp; iB.id &lt; m_nodeCapacity);</span>
<span class="nc bnc" id="L677" title="All 6 branches missed.">    assert (0 &lt;= iC.id &amp;&amp; iC.id &lt; m_nodeCapacity);</span>

<span class="nc" id="L679">    DynamicTreeNode B = iB;</span>
<span class="nc" id="L680">    DynamicTreeNode C = iC;</span>

<span class="nc" id="L682">    int balance = C.height - B.height;</span>

    // Rotate C up
<span class="nc bnc" id="L685" title="All 2 branches missed.">    if (balance &gt; 1) {</span>
<span class="nc" id="L686">      DynamicTreeNode iF = C.child1;</span>
<span class="nc" id="L687">      DynamicTreeNode iG = C.child2;</span>
<span class="nc" id="L688">      DynamicTreeNode F = iF;</span>
<span class="nc" id="L689">      DynamicTreeNode G = iG;</span>
<span class="nc bnc" id="L690" title="All 4 branches missed.">      assert (F != null);</span>
<span class="nc bnc" id="L691" title="All 4 branches missed.">      assert (G != null);</span>
<span class="nc bnc" id="L692" title="All 6 branches missed.">      assert (0 &lt;= iF.id &amp;&amp; iF.id &lt; m_nodeCapacity);</span>
<span class="nc bnc" id="L693" title="All 6 branches missed.">      assert (0 &lt;= iG.id &amp;&amp; iG.id &lt; m_nodeCapacity);</span>

      // Swap A and C
<span class="nc" id="L696">      C.child1 = iA;</span>
<span class="nc" id="L697">      C.parent = A.parent;</span>
<span class="nc" id="L698">      A.parent = iC;</span>

      // A's old parent should point to C
<span class="nc bnc" id="L701" title="All 2 branches missed.">      if (C.parent != null) {</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">        if (C.parent.child1 == iA) {</span>
<span class="nc" id="L703">          C.parent.child1 = iC;</span>
        } else {
<span class="nc bnc" id="L705" title="All 4 branches missed.">          assert (C.parent.child2 == iA);</span>
<span class="nc" id="L706">          C.parent.child2 = iC;</span>
        }
      } else {
<span class="nc" id="L709">        m_root = iC;</span>
      }

      // Rotate
<span class="nc bnc" id="L713" title="All 2 branches missed.">      if (F.height &gt; G.height) {</span>
<span class="nc" id="L714">        C.child2 = iF;</span>
<span class="nc" id="L715">        A.child2 = iG;</span>
<span class="nc" id="L716">        G.parent = iA;</span>
<span class="nc" id="L717">        A.aabb.combine(B.aabb, G.aabb);</span>
<span class="nc" id="L718">        C.aabb.combine(A.aabb, F.aabb);</span>

<span class="nc" id="L720">        A.height = 1 + MathUtils.max(B.height, G.height);</span>
<span class="nc" id="L721">        C.height = 1 + MathUtils.max(A.height, F.height);</span>
      } else {
<span class="nc" id="L723">        C.child2 = iG;</span>
<span class="nc" id="L724">        A.child2 = iF;</span>
<span class="nc" id="L725">        F.parent = iA;</span>
<span class="nc" id="L726">        A.aabb.combine(B.aabb, F.aabb);</span>
<span class="nc" id="L727">        C.aabb.combine(A.aabb, G.aabb);</span>

<span class="nc" id="L729">        A.height = 1 + MathUtils.max(B.height, F.height);</span>
<span class="nc" id="L730">        C.height = 1 + MathUtils.max(A.height, G.height);</span>
      }

<span class="nc" id="L733">      return iC;</span>
    }

    // Rotate B up
<span class="nc bnc" id="L737" title="All 2 branches missed.">    if (balance &lt; -1) {</span>
<span class="nc" id="L738">      DynamicTreeNode iD = B.child1;</span>
<span class="nc" id="L739">      DynamicTreeNode iE = B.child2;</span>
<span class="nc" id="L740">      DynamicTreeNode D = iD;</span>
<span class="nc" id="L741">      DynamicTreeNode E = iE;</span>
<span class="nc bnc" id="L742" title="All 6 branches missed.">      assert (0 &lt;= iD.id &amp;&amp; iD.id &lt; m_nodeCapacity);</span>
<span class="nc bnc" id="L743" title="All 6 branches missed.">      assert (0 &lt;= iE.id &amp;&amp; iE.id &lt; m_nodeCapacity);</span>

      // Swap A and B
<span class="nc" id="L746">      B.child1 = iA;</span>
<span class="nc" id="L747">      B.parent = A.parent;</span>
<span class="nc" id="L748">      A.parent = iB;</span>

      // A's old parent should point to B
<span class="nc bnc" id="L751" title="All 2 branches missed.">      if (B.parent != null) {</span>
<span class="nc bnc" id="L752" title="All 2 branches missed.">        if (B.parent.child1 == iA) {</span>
<span class="nc" id="L753">          B.parent.child1 = iB;</span>
        } else {
<span class="nc bnc" id="L755" title="All 4 branches missed.">          assert (B.parent.child2 == iA);</span>
<span class="nc" id="L756">          B.parent.child2 = iB;</span>
        }
      } else {
<span class="nc" id="L759">        m_root = iB;</span>
      }

      // Rotate
<span class="nc bnc" id="L763" title="All 2 branches missed.">      if (D.height &gt; E.height) {</span>
<span class="nc" id="L764">        B.child2 = iD;</span>
<span class="nc" id="L765">        A.child1 = iE;</span>
<span class="nc" id="L766">        E.parent = iA;</span>
<span class="nc" id="L767">        A.aabb.combine(C.aabb, E.aabb);</span>
<span class="nc" id="L768">        B.aabb.combine(A.aabb, D.aabb);</span>

<span class="nc" id="L770">        A.height = 1 + MathUtils.max(C.height, E.height);</span>
<span class="nc" id="L771">        B.height = 1 + MathUtils.max(A.height, D.height);</span>
      } else {
<span class="nc" id="L773">        B.child2 = iE;</span>
<span class="nc" id="L774">        A.child1 = iD;</span>
<span class="nc" id="L775">        D.parent = iA;</span>
<span class="nc" id="L776">        A.aabb.combine(C.aabb, D.aabb);</span>
<span class="nc" id="L777">        B.aabb.combine(A.aabb, E.aabb);</span>

<span class="nc" id="L779">        A.height = 1 + MathUtils.max(C.height, D.height);</span>
<span class="nc" id="L780">        B.height = 1 + MathUtils.max(A.height, E.height);</span>
      }

<span class="nc" id="L783">      return iB;</span>
    }

<span class="nc" id="L786">    return iA;</span>
  }

  private void validateStructure(DynamicTreeNode node) {
<span class="nc bnc" id="L790" title="All 2 branches missed.">    if (node == null) {</span>
<span class="nc" id="L791">      return;</span>
    }
<span class="nc bnc" id="L793" title="All 4 branches missed.">    assert (node == m_nodes[node.id]);</span>

<span class="nc bnc" id="L795" title="All 2 branches missed.">    if (node == m_root) {</span>
<span class="nc bnc" id="L796" title="All 4 branches missed.">      assert (node.parent == null);</span>
    }

<span class="nc" id="L799">    DynamicTreeNode child1 = node.child1;</span>
<span class="nc" id="L800">    DynamicTreeNode child2 = node.child2;</span>

<span class="nc bnc" id="L802" title="All 2 branches missed.">    if (node.isLeaf()) {</span>
<span class="nc bnc" id="L803" title="All 4 branches missed.">      assert (child1 == null);</span>
<span class="nc bnc" id="L804" title="All 4 branches missed.">      assert (child2 == null);</span>
<span class="nc bnc" id="L805" title="All 4 branches missed.">      assert (node.height == 0);</span>
<span class="nc" id="L806">      return;</span>
    }

<span class="nc bnc" id="L809" title="All 8 branches missed.">    assert (child1 != null &amp;&amp; 0 &lt;= child1.id &amp;&amp; child1.id &lt; m_nodeCapacity);</span>
<span class="nc bnc" id="L810" title="All 8 branches missed.">    assert (child2 != null &amp;&amp; 0 &lt;= child2.id &amp;&amp; child2.id &lt; m_nodeCapacity);</span>

<span class="nc bnc" id="L812" title="All 4 branches missed.">    assert (child1.parent == node);</span>
<span class="nc bnc" id="L813" title="All 4 branches missed.">    assert (child2.parent == node);</span>

<span class="nc" id="L815">    validateStructure(child1);</span>
<span class="nc" id="L816">    validateStructure(child2);</span>
<span class="nc" id="L817">  }</span>

  private void validateMetrics(DynamicTreeNode node) {
<span class="nc bnc" id="L820" title="All 2 branches missed.">    if (node == null) {</span>
<span class="nc" id="L821">      return;</span>
    }

<span class="nc" id="L824">    DynamicTreeNode child1 = node.child1;</span>
<span class="nc" id="L825">    DynamicTreeNode child2 = node.child2;</span>

<span class="nc bnc" id="L827" title="All 2 branches missed.">    if (node.isLeaf()) {</span>
<span class="nc bnc" id="L828" title="All 4 branches missed.">      assert (child1 == null);</span>
<span class="nc bnc" id="L829" title="All 4 branches missed.">      assert (child2 == null);</span>
<span class="nc bnc" id="L830" title="All 4 branches missed.">      assert (node.height == 0);</span>
<span class="nc" id="L831">      return;</span>
    }

<span class="nc bnc" id="L834" title="All 8 branches missed.">    assert (child1 != null &amp;&amp; 0 &lt;= child1.id &amp;&amp; child1.id &lt; m_nodeCapacity);</span>
<span class="nc bnc" id="L835" title="All 8 branches missed.">    assert (child2 != null &amp;&amp; 0 &lt;= child2.id &amp;&amp; child2.id &lt; m_nodeCapacity);</span>

<span class="nc" id="L837">    int height1 = child1.height;</span>
<span class="nc" id="L838">    int height2 = child2.height;</span>
    int height;
<span class="nc" id="L840">    height = 1 + MathUtils.max(height1, height2);</span>
<span class="nc bnc" id="L841" title="All 4 branches missed.">    assert (node.height == height);</span>

<span class="nc" id="L843">    AABB aabb = new AABB();</span>
<span class="nc" id="L844">    aabb.combine(child1.aabb, child2.aabb);</span>

<span class="nc bnc" id="L846" title="All 4 branches missed.">    assert (aabb.lowerBound.equals(node.aabb.lowerBound));</span>
<span class="nc bnc" id="L847" title="All 4 branches missed.">    assert (aabb.upperBound.equals(node.aabb.upperBound));</span>

<span class="nc" id="L849">    validateMetrics(child1);</span>
<span class="nc" id="L850">    validateMetrics(child2);</span>
<span class="nc" id="L851">  }</span>

  @Override
  public void drawTree(DebugDraw argDraw) {
<span class="nc bnc" id="L855" title="All 2 branches missed.">    if (m_root == null) {</span>
<span class="nc" id="L856">      return;</span>
    }
<span class="nc" id="L858">    int height = computeHeight();</span>
<span class="nc" id="L859">    drawTree(argDraw, m_root, 0, height);</span>
<span class="nc" id="L860">  }</span>

<span class="nc" id="L862">  private final Color3f color = new Color3f();</span>
<span class="nc" id="L863">  private final Vec2 textVec = new Vec2();</span>

  public void drawTree(DebugDraw argDraw, DynamicTreeNode node, int spot, int height) {
<span class="nc" id="L866">    node.aabb.getVertices(drawVecs);</span>

<span class="nc" id="L868">    color.set(1, (height - spot) * 1f / height, (height - spot) * 1f / height);</span>
<span class="nc" id="L869">    argDraw.drawPolygon(drawVecs, 4, color);</span>

<span class="nc" id="L871">    argDraw.getViewportTranform().getWorldToScreen(node.aabb.upperBound, textVec);</span>
<span class="nc" id="L872">    argDraw.drawString(textVec.x, textVec.y, node.id + &quot;-&quot; + (spot + 1) + &quot;/&quot; + height, color);</span>

<span class="nc bnc" id="L874" title="All 2 branches missed.">    if (node.child1 != null) {</span>
<span class="nc" id="L875">      drawTree(argDraw, node.child1, spot + 1, height);</span>
    }
<span class="nc bnc" id="L877" title="All 2 branches missed.">    if (node.child2 != null) {</span>
<span class="nc" id="L878">      drawTree(argDraw, node.child2, spot + 1, height);</span>
    }
<span class="nc" id="L880">  }</span>
  
<span class="nc bnc" id="L882" title="All 2 branches missed.">  public class TreeNodeStack {</span>
    private DynamicTreeNode[] stack;
    private int size;
    private int position;

<span class="nc" id="L887">    public TreeNodeStack(int initialSize) {</span>
<span class="nc" id="L888">      stack = new DynamicTreeNode[initialSize];</span>
<span class="nc" id="L889">      position = 0;</span>
<span class="nc" id="L890">      size = initialSize;</span>
<span class="nc" id="L891">    }</span>

    public void reset() {
<span class="nc" id="L894">      position = 0;</span>
<span class="nc" id="L895">    }</span>

    public DynamicTreeNode pop() {
<span class="nc bnc" id="L898" title="All 4 branches missed.">      assert (position &gt; 0);</span>
<span class="nc" id="L899">      return stack[--position];</span>
    }

    public void push(DynamicTreeNode i) {
<span class="nc bnc" id="L903" title="All 2 branches missed.">      if (position == size) {</span>
<span class="nc" id="L904">        DynamicTreeNode[] old = stack;</span>
<span class="nc" id="L905">        stack = new DynamicTreeNode[size * 2];</span>
<span class="nc" id="L906">        size = stack.length;</span>
<span class="nc" id="L907">        System.arraycopy(old, 0, stack, 0, old.length);</span>
      }
<span class="nc" id="L909">      stack[position++] = i;</span>
<span class="nc" id="L910">    }</span>

    public int getCount() {
<span class="nc" id="L913">      return position;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>