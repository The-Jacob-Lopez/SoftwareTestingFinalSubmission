<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ContactSolver.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jbox2d-library</a> &gt; <a href="index.source.html" class="el_package">org.jbox2d.dynamics.contacts</a> &gt; <span class="el_source">ContactSolver.java</span></div><h1>ContactSolver.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2013, Daniel Murphy
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 	* Redistributions of source code must retain the above copyright notice,
 * 	  this list of conditions and the following disclaimer.
 * 	* Redistributions in binary form must reproduce the above copyright notice,
 * 	  this list of conditions and the following disclaimer in the documentation
 * 	  and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************/
package org.jbox2d.dynamics.contacts;

import org.jbox2d.collision.Manifold;
import org.jbox2d.collision.ManifoldPoint;
import org.jbox2d.collision.WorldManifold;
import org.jbox2d.collision.shapes.Shape;
import org.jbox2d.common.Mat22;
import org.jbox2d.common.MathUtils;
import org.jbox2d.common.Rot;
import org.jbox2d.common.Settings;
import org.jbox2d.common.Transform;
import org.jbox2d.common.Vec2;
import org.jbox2d.dynamics.Body;
import org.jbox2d.dynamics.Fixture;
import org.jbox2d.dynamics.TimeStep;
import org.jbox2d.dynamics.contacts.ContactVelocityConstraint.VelocityConstraintPoint;

/**
 * @author Daniel
 */
<span class="nc bnc" id="L44" title="All 2 branches missed.">public class ContactSolver {</span>

  public static final boolean DEBUG_SOLVER = false;
  public static final float k_errorTol = 1e-3f;
  /**
   * For each solver, this is the initial number of constraints in the array, which expands as
   * needed.
   */
  public static final int INITIAL_NUM_CONSTRAINTS = 256;

  /**
   * Ensure a reasonable condition number. for the block solver
   */
  public static final float k_maxConditionNumber = 100.0f;

  public TimeStep m_step;
  public Position[] m_positions;
  public Velocity[] m_velocities;
  public ContactPositionConstraint[] m_positionConstraints;
  public ContactVelocityConstraint[] m_velocityConstraints;
  public Contact[] m_contacts;
  public int m_count;

<span class="nc" id="L67">  public ContactSolver() {</span>
<span class="nc" id="L68">    m_positionConstraints = new ContactPositionConstraint[INITIAL_NUM_CONSTRAINTS];</span>
<span class="nc" id="L69">    m_velocityConstraints = new ContactVelocityConstraint[INITIAL_NUM_CONSTRAINTS];</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">    for (int i = 0; i &lt; INITIAL_NUM_CONSTRAINTS; i++) {</span>
<span class="nc" id="L71">      m_positionConstraints[i] = new ContactPositionConstraint();</span>
<span class="nc" id="L72">      m_velocityConstraints[i] = new ContactVelocityConstraint();</span>
    }
<span class="nc" id="L74">  }</span>

  // djm pooling
<span class="nc" id="L77">  private final Vec2 tangent = new Vec2();</span>
<span class="nc" id="L78">  private final Vec2 temp1 = new Vec2();</span>
<span class="nc" id="L79">  private final Vec2 temp2 = new Vec2();</span>

  public final void init(ContactSolverDef def) {
    // System.out.println(&quot;Initializing contact solver&quot;);
<span class="nc" id="L83">    m_step = def.step;</span>
<span class="nc" id="L84">    m_count = def.count;</span>

<span class="nc bnc" id="L86" title="All 2 branches missed.">    if (m_positionConstraints.length &lt; m_count) {</span>
<span class="nc" id="L87">      ContactPositionConstraint[] old = m_positionConstraints;</span>
<span class="nc" id="L88">      m_positionConstraints = new ContactPositionConstraint[MathUtils.max(old.length * 2, m_count)];</span>
<span class="nc" id="L89">      System.arraycopy(old, 0, m_positionConstraints, 0, old.length);</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">      for (int i = old.length; i &lt; m_positionConstraints.length; i++) {</span>
<span class="nc" id="L91">        m_positionConstraints[i] = new ContactPositionConstraint();</span>
      }
    }

<span class="nc bnc" id="L95" title="All 2 branches missed.">    if (m_velocityConstraints.length &lt; m_count) {</span>
<span class="nc" id="L96">      ContactVelocityConstraint[] old = m_velocityConstraints;</span>
<span class="nc" id="L97">      m_velocityConstraints = new ContactVelocityConstraint[MathUtils.max(old.length * 2, m_count)];</span>
<span class="nc" id="L98">      System.arraycopy(old, 0, m_velocityConstraints, 0, old.length);</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">      for (int i = old.length; i &lt; m_velocityConstraints.length; i++) {</span>
<span class="nc" id="L100">        m_velocityConstraints[i] = new ContactVelocityConstraint();</span>
      }
    }

<span class="nc" id="L104">    m_positions = def.positions;</span>
<span class="nc" id="L105">    m_velocities = def.velocities;</span>
<span class="nc" id="L106">    m_contacts = def.contacts;</span>

<span class="nc bnc" id="L108" title="All 2 branches missed.">    for (int i = 0; i &lt; m_count; ++i) {</span>
      // System.out.println(&quot;contacts: &quot; + m_count);
<span class="nc" id="L110">      final Contact contact = m_contacts[i];</span>

<span class="nc" id="L112">      final Fixture fixtureA = contact.m_fixtureA;</span>
<span class="nc" id="L113">      final Fixture fixtureB = contact.m_fixtureB;</span>
<span class="nc" id="L114">      final Shape shapeA = fixtureA.getShape();</span>
<span class="nc" id="L115">      final Shape shapeB = fixtureB.getShape();</span>
<span class="nc" id="L116">      final float radiusA = shapeA.m_radius;</span>
<span class="nc" id="L117">      final float radiusB = shapeB.m_radius;</span>
<span class="nc" id="L118">      final Body bodyA = fixtureA.getBody();</span>
<span class="nc" id="L119">      final Body bodyB = fixtureB.getBody();</span>
<span class="nc" id="L120">      final Manifold manifold = contact.getManifold();</span>

<span class="nc" id="L122">      int pointCount = manifold.pointCount;</span>
<span class="nc bnc" id="L123" title="All 4 branches missed.">      assert (pointCount &gt; 0);</span>

<span class="nc" id="L125">      ContactVelocityConstraint vc = m_velocityConstraints[i];</span>
<span class="nc" id="L126">      vc.friction = contact.m_friction;</span>
<span class="nc" id="L127">      vc.restitution = contact.m_restitution;</span>
<span class="nc" id="L128">      vc.tangentSpeed = contact.m_tangentSpeed;</span>
<span class="nc" id="L129">      vc.indexA = bodyA.m_islandIndex;</span>
<span class="nc" id="L130">      vc.indexB = bodyB.m_islandIndex;</span>
<span class="nc" id="L131">      vc.invMassA = bodyA.m_invMass;</span>
<span class="nc" id="L132">      vc.invMassB = bodyB.m_invMass;</span>
<span class="nc" id="L133">      vc.invIA = bodyA.m_invI;</span>
<span class="nc" id="L134">      vc.invIB = bodyB.m_invI;</span>
<span class="nc" id="L135">      vc.contactIndex = i;</span>
<span class="nc" id="L136">      vc.pointCount = pointCount;</span>
<span class="nc" id="L137">      vc.K.setZero();</span>
<span class="nc" id="L138">      vc.normalMass.setZero();</span>

<span class="nc" id="L140">      ContactPositionConstraint pc = m_positionConstraints[i];</span>
<span class="nc" id="L141">      pc.indexA = bodyA.m_islandIndex;</span>
<span class="nc" id="L142">      pc.indexB = bodyB.m_islandIndex;</span>
<span class="nc" id="L143">      pc.invMassA = bodyA.m_invMass;</span>
<span class="nc" id="L144">      pc.invMassB = bodyB.m_invMass;</span>
<span class="nc" id="L145">      pc.localCenterA.set(bodyA.m_sweep.localCenter);</span>
<span class="nc" id="L146">      pc.localCenterB.set(bodyB.m_sweep.localCenter);</span>
<span class="nc" id="L147">      pc.invIA = bodyA.m_invI;</span>
<span class="nc" id="L148">      pc.invIB = bodyB.m_invI;</span>
<span class="nc" id="L149">      pc.localNormal.set(manifold.localNormal);</span>
<span class="nc" id="L150">      pc.localPoint.set(manifold.localPoint);</span>
<span class="nc" id="L151">      pc.pointCount = pointCount;</span>
<span class="nc" id="L152">      pc.radiusA = radiusA;</span>
<span class="nc" id="L153">      pc.radiusB = radiusB;</span>
<span class="nc" id="L154">      pc.type = manifold.type;</span>

      // System.out.println(&quot;contact point count: &quot; + pointCount);
<span class="nc bnc" id="L157" title="All 2 branches missed.">      for (int j = 0; j &lt; pointCount; j++) {</span>
<span class="nc" id="L158">        ManifoldPoint cp = manifold.points[j];</span>
<span class="nc" id="L159">        VelocityConstraintPoint vcp = vc.points[j];</span>

<span class="nc bnc" id="L161" title="All 2 branches missed.">        if (m_step.warmStarting) {</span>
          // assert(cp.normalImpulse == 0);
          // System.out.println(&quot;contact normal impulse: &quot; + cp.normalImpulse);
<span class="nc" id="L164">          vcp.normalImpulse = m_step.dtRatio * cp.normalImpulse;</span>
<span class="nc" id="L165">          vcp.tangentImpulse = m_step.dtRatio * cp.tangentImpulse;</span>
        } else {
<span class="nc" id="L167">          vcp.normalImpulse = 0;</span>
<span class="nc" id="L168">          vcp.tangentImpulse = 0;</span>
        }

<span class="nc" id="L171">        vcp.rA.setZero();</span>
<span class="nc" id="L172">        vcp.rB.setZero();</span>
<span class="nc" id="L173">        vcp.normalMass = 0;</span>
<span class="nc" id="L174">        vcp.tangentMass = 0;</span>
<span class="nc" id="L175">        vcp.velocityBias = 0;</span>
<span class="nc" id="L176">        pc.localPoints[j].x = cp.localPoint.x;</span>
<span class="nc" id="L177">        pc.localPoints[j].y = cp.localPoint.y;</span>
      }
    }
<span class="nc" id="L180">  }</span>

  // djm pooling, and from above
<span class="nc" id="L183">  private final Vec2 P = new Vec2();</span>
<span class="nc" id="L184">  private final Vec2 temp = new Vec2();</span>

  public void warmStart() {
    // Warm start.
<span class="nc bnc" id="L188" title="All 2 branches missed.">    for (int i = 0; i &lt; m_count; ++i) {</span>
<span class="nc" id="L189">      final ContactVelocityConstraint vc = m_velocityConstraints[i];</span>

<span class="nc" id="L191">      int indexA = vc.indexA;</span>
<span class="nc" id="L192">      int indexB = vc.indexB;</span>
<span class="nc" id="L193">      float mA = vc.invMassA;</span>
<span class="nc" id="L194">      float iA = vc.invIA;</span>
<span class="nc" id="L195">      float mB = vc.invMassB;</span>
<span class="nc" id="L196">      float iB = vc.invIB;</span>
<span class="nc" id="L197">      int pointCount = vc.pointCount;</span>

<span class="nc" id="L199">      Vec2 vA = m_velocities[indexA].v;</span>
<span class="nc" id="L200">      float wA = m_velocities[indexA].w;</span>
<span class="nc" id="L201">      Vec2 vB = m_velocities[indexB].v;</span>
<span class="nc" id="L202">      float wB = m_velocities[indexB].w;</span>

<span class="nc" id="L204">      Vec2 normal = vc.normal;</span>
<span class="nc" id="L205">      float tangentx = 1.0f * normal.y;</span>
<span class="nc" id="L206">      float tangenty = -1.0f * normal.x;</span>

<span class="nc bnc" id="L208" title="All 2 branches missed.">      for (int j = 0; j &lt; pointCount; ++j) {</span>
<span class="nc" id="L209">        VelocityConstraintPoint vcp = vc.points[j];</span>
<span class="nc" id="L210">        float Px = tangentx * vcp.tangentImpulse + normal.x * vcp.normalImpulse;</span>
<span class="nc" id="L211">        float Py = tangenty * vcp.tangentImpulse + normal.y * vcp.normalImpulse;</span>

<span class="nc" id="L213">        wA -= iA * (vcp.rA.x * Py - vcp.rA.y * Px);</span>
<span class="nc" id="L214">        vA.x -= Px * mA;</span>
<span class="nc" id="L215">        vA.y -= Py * mA;</span>
<span class="nc" id="L216">        wB += iB * (vcp.rB.x * Py - vcp.rB.y * Px);</span>
<span class="nc" id="L217">        vB.x += Px * mB;</span>
<span class="nc" id="L218">        vB.y += Py * mB;</span>
      }
<span class="nc" id="L220">      m_velocities[indexA].w = wA;</span>
<span class="nc" id="L221">      m_velocities[indexB].w = wB;</span>
    }
<span class="nc" id="L223">  }</span>

  // djm pooling, and from above
<span class="nc" id="L226">  private final Transform xfA = new Transform();</span>
<span class="nc" id="L227">  private final Transform xfB = new Transform();</span>
<span class="nc" id="L228">  private final WorldManifold worldManifold = new WorldManifold();</span>

  public final void initializeVelocityConstraints() {

    // Warm start.
<span class="nc bnc" id="L233" title="All 2 branches missed.">    for (int i = 0; i &lt; m_count; ++i) {</span>
<span class="nc" id="L234">      ContactVelocityConstraint vc = m_velocityConstraints[i];</span>
<span class="nc" id="L235">      ContactPositionConstraint pc = m_positionConstraints[i];</span>

<span class="nc" id="L237">      float radiusA = pc.radiusA;</span>
<span class="nc" id="L238">      float radiusB = pc.radiusB;</span>
<span class="nc" id="L239">      Manifold manifold = m_contacts[vc.contactIndex].getManifold();</span>

<span class="nc" id="L241">      int indexA = vc.indexA;</span>
<span class="nc" id="L242">      int indexB = vc.indexB;</span>

<span class="nc" id="L244">      float mA = vc.invMassA;</span>
<span class="nc" id="L245">      float mB = vc.invMassB;</span>
<span class="nc" id="L246">      float iA = vc.invIA;</span>
<span class="nc" id="L247">      float iB = vc.invIB;</span>
<span class="nc" id="L248">      Vec2 localCenterA = pc.localCenterA;</span>
<span class="nc" id="L249">      Vec2 localCenterB = pc.localCenterB;</span>

<span class="nc" id="L251">      Vec2 cA = m_positions[indexA].c;</span>
<span class="nc" id="L252">      float aA = m_positions[indexA].a;</span>
<span class="nc" id="L253">      Vec2 vA = m_velocities[indexA].v;</span>
<span class="nc" id="L254">      float wA = m_velocities[indexA].w;</span>

<span class="nc" id="L256">      Vec2 cB = m_positions[indexB].c;</span>
<span class="nc" id="L257">      float aB = m_positions[indexB].a;</span>
<span class="nc" id="L258">      Vec2 vB = m_velocities[indexB].v;</span>
<span class="nc" id="L259">      float wB = m_velocities[indexB].w;</span>

<span class="nc bnc" id="L261" title="All 4 branches missed.">      assert (manifold.pointCount &gt; 0);</span>

<span class="nc" id="L263">      xfA.q.set(aA);</span>
<span class="nc" id="L264">      xfB.q.set(aB);</span>
<span class="nc" id="L265">      xfA.p.x = cA.x - (xfA.q.c * localCenterA.x - xfA.q.s * localCenterA.y);</span>
<span class="nc" id="L266">      xfA.p.y = cA.y - (xfA.q.s * localCenterA.x + xfA.q.c * localCenterA.y);</span>
<span class="nc" id="L267">      xfB.p.x = cB.x - (xfB.q.c * localCenterB.x - xfB.q.s * localCenterB.y);</span>
<span class="nc" id="L268">      xfB.p.y = cB.y - (xfB.q.s * localCenterB.x + xfB.q.c * localCenterB.y);</span>

<span class="nc" id="L270">      worldManifold.initialize(manifold, xfA, radiusA, xfB, radiusB);</span>

<span class="nc" id="L272">      vc.normal.set(worldManifold.normal);</span>

<span class="nc" id="L274">      int pointCount = vc.pointCount;</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">      for (int j = 0; j &lt; pointCount; ++j) {</span>
<span class="nc" id="L276">        VelocityConstraintPoint vcp = vc.points[j];</span>

<span class="nc" id="L278">        vcp.rA.set(worldManifold.points[j]).subLocal(cA);</span>
<span class="nc" id="L279">        vcp.rB.set(worldManifold.points[j]).subLocal(cB);</span>

<span class="nc" id="L281">        float rnA = vcp.rA.x * vc.normal.y - vcp.rA.y * vc.normal.x;</span>
<span class="nc" id="L282">        float rnB = vcp.rB.x * vc.normal.y - vcp.rB.y * vc.normal.x;</span>

<span class="nc" id="L284">        float kNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB;</span>

<span class="nc bnc" id="L286" title="All 2 branches missed.">        vcp.normalMass = kNormal &gt; 0.0f ? 1.0f / kNormal : 0.0f;</span>

<span class="nc" id="L288">        float tangentx = 1.0f * vc.normal.y;</span>
<span class="nc" id="L289">        float tangenty = -1.0f * vc.normal.x;</span>

<span class="nc" id="L291">        float rtA = vcp.rA.x * tangenty - vcp.rA.y * tangentx;</span>
<span class="nc" id="L292">        float rtB = vcp.rB.x * tangenty - vcp.rB.y * tangentx;</span>

<span class="nc" id="L294">        float kTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB;</span>

<span class="nc bnc" id="L296" title="All 2 branches missed.">        vcp.tangentMass = kTangent &gt; 0.0f ? 1.0f / kTangent : 0.0f;</span>

        // Setup a velocity bias for restitution.
<span class="nc" id="L299">        vcp.velocityBias = 0.0f;</span>
<span class="nc" id="L300">        float tempx = vB.x + -wB * vcp.rB.y - vA.x - (-wA * vcp.rA.y);</span>
<span class="nc" id="L301">        float tempy = vB.y + wB * vcp.rB.x - vA.y - (wA * vcp.rA.x);</span>
<span class="nc" id="L302">        float vRel = vc.normal.x * tempx + vc.normal.y * tempy;</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">        if (vRel &lt; -Settings.velocityThreshold) {</span>
<span class="nc" id="L304">          vcp.velocityBias = -vc.restitution * vRel;</span>
        }
      }

      // If we have two points, then prepare the block solver.
<span class="nc bnc" id="L309" title="All 2 branches missed.">      if (vc.pointCount == 2) {</span>
<span class="nc" id="L310">        VelocityConstraintPoint vcp1 = vc.points[0];</span>
<span class="nc" id="L311">        VelocityConstraintPoint vcp2 = vc.points[1];</span>

<span class="nc" id="L313">        float rn1A = Vec2.cross(vcp1.rA, vc.normal);</span>
<span class="nc" id="L314">        float rn1B = Vec2.cross(vcp1.rB, vc.normal);</span>
<span class="nc" id="L315">        float rn2A = Vec2.cross(vcp2.rA, vc.normal);</span>
<span class="nc" id="L316">        float rn2B = Vec2.cross(vcp2.rB, vc.normal);</span>

<span class="nc" id="L318">        float k11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B;</span>
<span class="nc" id="L319">        float k22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B;</span>
<span class="nc" id="L320">        float k12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B;</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">        if (k11 * k11 &lt; k_maxConditionNumber * (k11 * k22 - k12 * k12)) {</span>
          // K is safe to invert.
<span class="nc" id="L323">          vc.K.ex.set(k11, k12);</span>
<span class="nc" id="L324">          vc.K.ey.set(k12, k22);</span>
<span class="nc" id="L325">          vc.K.invertToOut(vc.normalMass);</span>
        } else {
          // The constraints are redundant, just use one.
          // TODO_ERIN use deepest?
<span class="nc" id="L329">          vc.pointCount = 1;</span>
        }
      }
    }
<span class="nc" id="L333">  }</span>

  // djm pooling from above
<span class="nc" id="L336">  private final Vec2 a = new Vec2();</span>
<span class="nc" id="L337">  private final Vec2 b = new Vec2();</span>
<span class="nc" id="L338">  private final Vec2 dv1 = new Vec2();</span>
<span class="nc" id="L339">  private final Vec2 dv2 = new Vec2();</span>
<span class="nc" id="L340">  private final Vec2 x = new Vec2();</span>
<span class="nc" id="L341">  private final Vec2 d = new Vec2();</span>
<span class="nc" id="L342">  private final Vec2 P1 = new Vec2();</span>
<span class="nc" id="L343">  private final Vec2 P2 = new Vec2();</span>

  public final void solveVelocityConstraints() {
<span class="nc bnc" id="L346" title="All 2 branches missed.">    for (int i = 0; i &lt; m_count; ++i) {</span>
<span class="nc" id="L347">      final ContactVelocityConstraint vc = m_velocityConstraints[i];</span>

<span class="nc" id="L349">      int indexA = vc.indexA;</span>
<span class="nc" id="L350">      int indexB = vc.indexB;</span>

<span class="nc" id="L352">      float mA = vc.invMassA;</span>
<span class="nc" id="L353">      float mB = vc.invMassB;</span>
<span class="nc" id="L354">      float iA = vc.invIA;</span>
<span class="nc" id="L355">      float iB = vc.invIB;</span>
<span class="nc" id="L356">      int pointCount = vc.pointCount;</span>

<span class="nc" id="L358">      Vec2 vA = m_velocities[indexA].v;</span>
<span class="nc" id="L359">      float wA = m_velocities[indexA].w;</span>
<span class="nc" id="L360">      Vec2 vB = m_velocities[indexB].v;</span>
<span class="nc" id="L361">      float wB = m_velocities[indexB].w;</span>

<span class="nc" id="L363">      Vec2 normal = vc.normal;</span>
<span class="nc" id="L364">      tangent.x = 1.0f * vc.normal.y;</span>
<span class="nc" id="L365">      tangent.y = -1.0f * vc.normal.x;</span>
<span class="nc" id="L366">      final float friction = vc.friction;</span>

<span class="nc bnc" id="L368" title="All 6 branches missed.">      assert (pointCount == 1 || pointCount == 2);</span>

      // Solve tangent constraints
<span class="nc bnc" id="L371" title="All 2 branches missed.">      for (int j = 0; j &lt; pointCount; ++j) {</span>
<span class="nc" id="L372">        final VelocityConstraintPoint vcp = vc.points[j];</span>
<span class="nc" id="L373">        final Vec2 a = vcp.rA;</span>
<span class="nc" id="L374">        float dvx = -wB * vcp.rB.y + vB.x - vA.x + wA * a.y;</span>
<span class="nc" id="L375">        float dvy = wB * vcp.rB.x + vB.y - vA.y - wA * a.x;</span>

        // Compute tangent force
<span class="nc" id="L378">        final float vt = dvx * tangent.x + dvy * tangent.y - vc.tangentSpeed;</span>
<span class="nc" id="L379">        float lambda = vcp.tangentMass * (-vt);</span>

        // Clamp the accumulated force
<span class="nc" id="L382">        final float maxFriction = friction * vcp.normalImpulse;</span>
<span class="nc" id="L383">        final float newImpulse =</span>
<span class="nc" id="L384">            MathUtils.clamp(vcp.tangentImpulse + lambda, -maxFriction, maxFriction);</span>
<span class="nc" id="L385">        lambda = newImpulse - vcp.tangentImpulse;</span>
<span class="nc" id="L386">        vcp.tangentImpulse = newImpulse;</span>

        // Apply contact impulse
        // Vec2 P = lambda * tangent;

<span class="nc" id="L391">        final float Px = tangent.x * lambda;</span>
<span class="nc" id="L392">        final float Py = tangent.y * lambda;</span>

        // vA -= invMassA * P;
<span class="nc" id="L395">        vA.x -= Px * mA;</span>
<span class="nc" id="L396">        vA.y -= Py * mA;</span>
<span class="nc" id="L397">        wA -= iA * (vcp.rA.x * Py - vcp.rA.y * Px);</span>

        // vB += invMassB * P;
<span class="nc" id="L400">        vB.x += Px * mB;</span>
<span class="nc" id="L401">        vB.y += Py * mB;</span>
<span class="nc" id="L402">        wB += iB * (vcp.rB.x * Py - vcp.rB.y * Px);</span>
      }

      // Solve normal constraints
<span class="nc bnc" id="L406" title="All 2 branches missed.">      if (vc.pointCount == 1) {</span>
<span class="nc" id="L407">        final VelocityConstraintPoint vcp = vc.points[0];</span>

        // Relative velocity at contact
        // Vec2 dv = vB + Cross(wB, vcp.rB) - vA - Cross(wA, vcp.rA);

<span class="nc" id="L412">        float dvx = -wB * vcp.rB.y + vB.x - vA.x + wA * vcp.rA.y;</span>
<span class="nc" id="L413">        float dvy = wB * vcp.rB.x + vB.y - vA.y - wA * vcp.rA.x;</span>

        // Compute normal impulse
<span class="nc" id="L416">        final float vn = dvx * normal.x + dvy * normal.y;</span>
<span class="nc" id="L417">        float lambda = -vcp.normalMass * (vn - vcp.velocityBias);</span>

        // Clamp the accumulated impulse
<span class="nc" id="L420">        float a = vcp.normalImpulse + lambda;</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">        final float newImpulse = (a &gt; 0.0f ? a : 0.0f);</span>
<span class="nc" id="L422">        lambda = newImpulse - vcp.normalImpulse;</span>
<span class="nc" id="L423">        vcp.normalImpulse = newImpulse;</span>

        // Apply contact impulse
<span class="nc" id="L426">        float Px = normal.x * lambda;</span>
<span class="nc" id="L427">        float Py = normal.y * lambda;</span>

        // vA -= invMassA * P;
<span class="nc" id="L430">        vA.x -= Px * mA;</span>
<span class="nc" id="L431">        vA.y -= Py * mA;</span>
<span class="nc" id="L432">        wA -= iA * (vcp.rA.x * Py - vcp.rA.y * Px);</span>

        // vB += invMassB * P;
<span class="nc" id="L435">        vB.x += Px * mB;</span>
<span class="nc" id="L436">        vB.y += Py * mB;</span>
<span class="nc" id="L437">        wB += iB * (vcp.rB.x * Py - vcp.rB.y * Px);</span>
<span class="nc" id="L438">      } else {</span>
        // Block solver developed in collaboration with Dirk Gregorius (back in 01/07 on
        // Box2D_Lite).
        // Build the mini LCP for this contact patch
        //
        // vn = A * x + b, vn &gt;= 0, , vn &gt;= 0, x &gt;= 0 and vn_i * x_i = 0 with i = 1..2
        //
        // A = J * W * JT and J = ( -n, -r1 x n, n, r2 x n )
        // b = vn_0 - velocityBias
        //
        // The system is solved using the &quot;Total enumeration method&quot; (s. Murty). The complementary
        // constraint vn_i * x_i
        // implies that we must have in any solution either vn_i = 0 or x_i = 0. So for the 2D
        // contact problem the cases
        // vn1 = 0 and vn2 = 0, x1 = 0 and x2 = 0, x1 = 0 and vn2 = 0, x2 = 0 and vn1 = 0 need to be
        // tested. The first valid
        // solution that satisfies the problem is chosen.
        //
        // In order to account of the accumulated impulse 'a' (because of the iterative nature of
        // the solver which only requires
        // that the accumulated impulse is clamped and not the incremental impulse) we change the
        // impulse variable (x_i).
        //
        // Substitute:
        //
        // x = a + d
        //
        // a := old total impulse
        // x := new total impulse
        // d := incremental impulse
        //
        // For the current iteration we extend the formula for the incremental impulse
        // to compute the new total impulse:
        //
        // vn = A * d + b
        // = A * (x - a) + b
        // = A * x + b - A * a
        // = A * x + b'
        // b' = b - A * a;

<span class="nc" id="L478">        final VelocityConstraintPoint cp1 = vc.points[0];</span>
<span class="nc" id="L479">        final VelocityConstraintPoint cp2 = vc.points[1];</span>
<span class="nc" id="L480">        a.x = cp1.normalImpulse;</span>
<span class="nc" id="L481">        a.y = cp2.normalImpulse;</span>

<span class="nc bnc" id="L483" title="All 6 branches missed.">        assert (a.x &gt;= 0.0f &amp;&amp; a.y &gt;= 0.0f);</span>
        // Relative velocity at contact
        // Vec2 dv1 = vB + Cross(wB, cp1.rB) - vA - Cross(wA, cp1.rA);
<span class="nc" id="L486">        dv1.x = -wB * cp1.rB.y + vB.x - vA.x + wA * cp1.rA.y;</span>
<span class="nc" id="L487">        dv1.y = wB * cp1.rB.x + vB.y - vA.y - wA * cp1.rA.x;</span>

        // Vec2 dv2 = vB + Cross(wB, cp2.rB) - vA - Cross(wA, cp2.rA);
<span class="nc" id="L490">        dv2.x = -wB * cp2.rB.y + vB.x - vA.x + wA * cp2.rA.y;</span>
<span class="nc" id="L491">        dv2.y = wB * cp2.rB.x + vB.y - vA.y - wA * cp2.rA.x;</span>

        // Compute normal velocity
<span class="nc" id="L494">        float vn1 = dv1.x * normal.x + dv1.y * normal.y;</span>
<span class="nc" id="L495">        float vn2 = dv2.x * normal.x + dv2.y * normal.y;</span>

<span class="nc" id="L497">        b.x = vn1 - cp1.velocityBias;</span>
<span class="nc" id="L498">        b.y = vn2 - cp2.velocityBias;</span>
        // System.out.println(&quot;b is &quot; + b.x + &quot;,&quot; + b.y);

        // Compute b'
<span class="nc" id="L502">        Mat22 R = vc.K;</span>
<span class="nc" id="L503">        b.x -= R.ex.x * a.x + R.ey.x * a.y;</span>
<span class="nc" id="L504">        b.y -= R.ex.y * a.x + R.ey.y * a.y;</span>
        // System.out.println(&quot;b' is &quot; + b.x + &quot;,&quot; + b.y);

        // final float k_errorTol = 1e-3f;
        // B2_NOT_USED(k_errorTol);
        for (;;) {
          //
          // Case 1: vn = 0
          //
          // 0 = A * x' + b'
          //
          // Solve for x':
          //
          // x' = - inv(A) * b'
          //
          // Vec2 x = - Mul(c.normalMass, b);
<span class="nc" id="L520">          Mat22.mulToOutUnsafe(vc.normalMass, b, x);</span>
<span class="nc" id="L521">          x.x *= -1;</span>
<span class="nc" id="L522">          x.y *= -1;</span>

<span class="nc bnc" id="L524" title="All 4 branches missed.">          if (x.x &gt;= 0.0f &amp;&amp; x.y &gt;= 0.0f) {</span>
            // System.out.println(&quot;case 1&quot;);
            // Get the incremental impulse
            // Vec2 d = x - a;
<span class="nc" id="L528">            d.set(x).subLocal(a);</span>

            // Apply incremental impulse
            // Vec2 P1 = d.x * normal;
            // Vec2 P2 = d.y * normal;
<span class="nc" id="L533">            P1.set(normal).mulLocal(d.x);</span>
<span class="nc" id="L534">            P2.set(normal).mulLocal(d.y);</span>

            /*
             * vA -= invMassA * (P1 + P2); wA -= invIA * (Cross(cp1.rA, P1) + Cross(cp2.rA, P2));
             * 
             * vB += invMassB * (P1 + P2); wB += invIB * (Cross(cp1.rB, P1) + Cross(cp2.rB, P2));
             */

<span class="nc" id="L542">            temp1.set(P1).addLocal(P2);</span>
<span class="nc" id="L543">            temp2.set(temp1).mulLocal(mA);</span>
<span class="nc" id="L544">            vA.subLocal(temp2);</span>
<span class="nc" id="L545">            temp2.set(temp1).mulLocal(mB);</span>
<span class="nc" id="L546">            vB.addLocal(temp2);</span>

<span class="nc" id="L548">            wA -= iA * (Vec2.cross(cp1.rA, P1) + Vec2.cross(cp2.rA, P2));</span>
<span class="nc" id="L549">            wB += iB * (Vec2.cross(cp1.rB, P1) + Vec2.cross(cp2.rB, P2));</span>

            // Accumulate
<span class="nc" id="L552">            cp1.normalImpulse = x.x;</span>
<span class="nc" id="L553">            cp2.normalImpulse = x.y;</span>

            /*
             * #if B2_DEBUG_SOLVER == 1 // Postconditions dv1 = vB + Cross(wB, cp1.rB) - vA -
             * Cross(wA, cp1.rA); dv2 = vB + Cross(wB, cp2.rB) - vA - Cross(wA, cp2.rA);
             * 
             * // Compute normal velocity vn1 = Dot(dv1, normal); vn2 = Dot(dv2, normal);
             * 
             * assert(Abs(vn1 - cp1.velocityBias) &lt; k_errorTol); assert(Abs(vn2 - cp2.velocityBias)
             * &lt; k_errorTol); #endif
             */
            if (DEBUG_SOLVER) {
              // Postconditions
              Vec2 dv1 =
                  vB.add(Vec2.cross(wB, cp1.rB).subLocal(vA).subLocal(Vec2.cross(wA, cp1.rA)));
              Vec2 dv2 =
                  vB.add(Vec2.cross(wB, cp2.rB).subLocal(vA).subLocal(Vec2.cross(wA, cp2.rA)));
              // Compute normal velocity
              vn1 = Vec2.dot(dv1, normal);
              vn2 = Vec2.dot(dv2, normal);

              assert (MathUtils.abs(vn1 - cp1.velocityBias) &lt; k_errorTol);
              assert (MathUtils.abs(vn2 - cp2.velocityBias) &lt; k_errorTol);
            }
<span class="nc" id="L577">            break;</span>
          }

          //
          // Case 2: vn1 = 0 and x2 = 0
          //
          // 0 = a11 * x1' + a12 * 0 + b1'
          // vn2 = a21 * x1' + a22 * 0 + '
          //
<span class="nc" id="L586">          x.x = -cp1.normalMass * b.x;</span>
<span class="nc" id="L587">          x.y = 0.0f;</span>
<span class="nc" id="L588">          vn1 = 0.0f;</span>
<span class="nc" id="L589">          vn2 = vc.K.ex.y * x.x + b.y;</span>

<span class="nc bnc" id="L591" title="All 4 branches missed.">          if (x.x &gt;= 0.0f &amp;&amp; vn2 &gt;= 0.0f) {</span>
            // System.out.println(&quot;case 2&quot;);
            // Get the incremental impulse
<span class="nc" id="L594">            d.set(x).subLocal(a);</span>

            // Apply incremental impulse
            // Vec2 P1 = d.x * normal;
            // Vec2 P2 = d.y * normal;
<span class="nc" id="L599">            P1.set(normal).mulLocal(d.x);</span>
<span class="nc" id="L600">            P2.set(normal).mulLocal(d.y);</span>

            /*
             * Vec2 P1 = d.x * normal; Vec2 P2 = d.y * normal; vA -= invMassA * (P1 + P2); wA -=
             * invIA * (Cross(cp1.rA, P1) + Cross(cp2.rA, P2));
             * 
             * vB += invMassB * (P1 + P2); wB += invIB * (Cross(cp1.rB, P1) + Cross(cp2.rB, P2));
             */

<span class="nc" id="L609">            temp1.set(P1).addLocal(P2);</span>
<span class="nc" id="L610">            temp2.set(temp1).mulLocal(mA);</span>
<span class="nc" id="L611">            vA.subLocal(temp2);</span>
<span class="nc" id="L612">            temp2.set(temp1).mulLocal(mB);</span>
<span class="nc" id="L613">            vB.addLocal(temp2);</span>

<span class="nc" id="L615">            wA -= iA * (Vec2.cross(cp1.rA, P1) + Vec2.cross(cp2.rA, P2));</span>
<span class="nc" id="L616">            wB += iB * (Vec2.cross(cp1.rB, P1) + Vec2.cross(cp2.rB, P2));</span>

            // Accumulate
<span class="nc" id="L619">            cp1.normalImpulse = x.x;</span>
<span class="nc" id="L620">            cp2.normalImpulse = x.y;</span>

            /*
             * #if B2_DEBUG_SOLVER == 1 // Postconditions dv1 = vB + Cross(wB, cp1.rB) - vA -
             * Cross(wA, cp1.rA);
             * 
             * // Compute normal velocity vn1 = Dot(dv1, normal);
             * 
             * assert(Abs(vn1 - cp1.velocityBias) &lt; k_errorTol); #endif
             */
            if (DEBUG_SOLVER) {
              // Postconditions
              Vec2 dv1 =
                  vB.add(Vec2.cross(wB, cp1.rB).subLocal(vA).subLocal(Vec2.cross(wA, cp1.rA)));
              // Compute normal velocity
              vn1 = Vec2.dot(dv1, normal);

              assert (MathUtils.abs(vn1 - cp1.velocityBias) &lt; k_errorTol);
            }
<span class="nc" id="L639">            break;</span>
          }

          //
          // Case 3: wB = 0 and x1 = 0
          //
          // vn1 = a11 * 0 + a12 * x2' + b1'
          // 0 = a21 * 0 + a22 * x2' + '
          //
<span class="nc" id="L648">          x.x = 0.0f;</span>
<span class="nc" id="L649">          x.y = -cp2.normalMass * b.y;</span>
<span class="nc" id="L650">          vn1 = vc.K.ey.x * x.y + b.x;</span>
<span class="nc" id="L651">          vn2 = 0.0f;</span>

<span class="nc bnc" id="L653" title="All 4 branches missed.">          if (x.y &gt;= 0.0f &amp;&amp; vn1 &gt;= 0.0f) {</span>
            // System.out.println(&quot;case 3&quot;);
            // Resubstitute for the incremental impulse
<span class="nc" id="L656">            d.set(x).subLocal(a);</span>

            // Apply incremental impulse
            /*
             * Vec2 P1 = d.x * normal; Vec2 P2 = d.y * normal; vA -= invMassA * (P1 + P2); wA -=
             * invIA * (Cross(cp1.rA, P1) + Cross(cp2.rA, P2));
             * 
             * vB += invMassB * (P1 + P2); wB += invIB * (Cross(cp1.rB, P1) + Cross(cp2.rB, P2));
             */

<span class="nc" id="L666">            P1.set(normal).mulLocal(d.x);</span>
<span class="nc" id="L667">            P2.set(normal).mulLocal(d.y);</span>

<span class="nc" id="L669">            temp1.set(P1).addLocal(P2);</span>
<span class="nc" id="L670">            temp2.set(temp1).mulLocal(mA);</span>
<span class="nc" id="L671">            vA.subLocal(temp2);</span>
<span class="nc" id="L672">            temp2.set(temp1).mulLocal(mB);</span>
<span class="nc" id="L673">            vB.addLocal(temp2);</span>

<span class="nc" id="L675">            wA -= iA * (Vec2.cross(cp1.rA, P1) + Vec2.cross(cp2.rA, P2));</span>
<span class="nc" id="L676">            wB += iB * (Vec2.cross(cp1.rB, P1) + Vec2.cross(cp2.rB, P2));</span>

            // Accumulate
<span class="nc" id="L679">            cp1.normalImpulse = x.x;</span>
<span class="nc" id="L680">            cp2.normalImpulse = x.y;</span>

            /*
             * #if B2_DEBUG_SOLVER == 1 // Postconditions dv2 = vB + Cross(wB, cp2.rB) - vA -
             * Cross(wA, cp2.rA);
             * 
             * // Compute normal velocity vn2 = Dot(dv2, normal);
             * 
             * assert(Abs(vn2 - cp2.velocityBias) &lt; k_errorTol); #endif
             */
            if (DEBUG_SOLVER) {
              // Postconditions
              Vec2 dv2 =
                  vB.add(Vec2.cross(wB, cp2.rB).subLocal(vA).subLocal(Vec2.cross(wA, cp2.rA)));
              // Compute normal velocity
              vn2 = Vec2.dot(dv2, normal);

              assert (MathUtils.abs(vn2 - cp2.velocityBias) &lt; k_errorTol);
            }
<span class="nc" id="L699">            break;</span>
          }

          //
          // Case 4: x1 = 0 and x2 = 0
          //
          // vn1 = b1
          // vn2 = ;
<span class="nc" id="L707">          x.x = 0.0f;</span>
<span class="nc" id="L708">          x.y = 0.0f;</span>
<span class="nc" id="L709">          vn1 = b.x;</span>
<span class="nc" id="L710">          vn2 = b.y;</span>

<span class="nc bnc" id="L712" title="All 4 branches missed.">          if (vn1 &gt;= 0.0f &amp;&amp; vn2 &gt;= 0.0f) {</span>
            // System.out.println(&quot;case 4&quot;);
            // Resubstitute for the incremental impulse
<span class="nc" id="L715">            d.set(x).subLocal(a);</span>

            // Apply incremental impulse
            /*
             * Vec2 P1 = d.x * normal; Vec2 P2 = d.y * normal; vA -= invMassA * (P1 + P2); wA -=
             * invIA * (Cross(cp1.rA, P1) + Cross(cp2.rA, P2));
             * 
             * vB += invMassB * (P1 + P2); wB += invIB * (Cross(cp1.rB, P1) + Cross(cp2.rB, P2));
             */

<span class="nc" id="L725">            P1.set(normal).mulLocal(d.x);</span>
<span class="nc" id="L726">            P2.set(normal).mulLocal(d.y);</span>

<span class="nc" id="L728">            temp1.set(P1).addLocal(P2);</span>
<span class="nc" id="L729">            temp2.set(temp1).mulLocal(mA);</span>
<span class="nc" id="L730">            vA.subLocal(temp2);</span>
<span class="nc" id="L731">            temp2.set(temp1).mulLocal(mB);</span>
<span class="nc" id="L732">            vB.addLocal(temp2);</span>

<span class="nc" id="L734">            wA -= iA * (Vec2.cross(cp1.rA, P1) + Vec2.cross(cp2.rA, P2));</span>
<span class="nc" id="L735">            wB += iB * (Vec2.cross(cp1.rB, P1) + Vec2.cross(cp2.rB, P2));</span>

            // Accumulate
<span class="nc" id="L738">            cp1.normalImpulse = x.x;</span>
<span class="nc" id="L739">            cp2.normalImpulse = x.y;</span>

            break;
          }

          // No solution, give up. This is hit sometimes, but it doesn't seem to matter.
          break;
        }
      }

      // m_velocities[indexA].v.set(vA);
<span class="nc" id="L750">      m_velocities[indexA].w = wA;</span>
      // m_velocities[indexB].v.set(vB);
<span class="nc" id="L752">      m_velocities[indexB].w = wB;</span>
    }
<span class="nc" id="L754">  }</span>

  public void storeImpulses() {
<span class="nc bnc" id="L757" title="All 2 branches missed.">    for (int i = 0; i &lt; m_count; i++) {</span>
<span class="nc" id="L758">      final ContactVelocityConstraint vc = m_velocityConstraints[i];</span>
<span class="nc" id="L759">      final Manifold manifold = m_contacts[vc.contactIndex].getManifold();</span>

<span class="nc bnc" id="L761" title="All 2 branches missed.">      for (int j = 0; j &lt; vc.pointCount; j++) {</span>
<span class="nc" id="L762">        manifold.points[j].normalImpulse = vc.points[j].normalImpulse;</span>
<span class="nc" id="L763">        manifold.points[j].tangentImpulse = vc.points[j].tangentImpulse;</span>
      }
    }
<span class="nc" id="L766">  }</span>

  /*
   * #if 0 // Sequential solver. bool ContactSolver::SolvePositionConstraints(float baumgarte) {
   * float minSeparation = 0.0f;
   * 
   * for (int i = 0; i &lt; m_constraintCount; ++i) { ContactConstraint* c = m_constraints + i; Body*
   * bodyA = c.bodyA; Body* bodyB = c.bodyB; float invMassA = bodyA.m_mass * bodyA.m_invMass; float
   * invIA = bodyA.m_mass * bodyA.m_invI; float invMassB = bodyB.m_mass * bodyB.m_invMass; float
   * invIB = bodyB.m_mass * bodyB.m_invI;
   * 
   * Vec2 normal = c.normal;
   * 
   * // Solve normal constraints for (int j = 0; j &lt; c.pointCount; ++j) { ContactConstraintPoint*
   * ccp = c.points + j;
   * 
   * Vec2 r1 = Mul(bodyA.GetXForm().R, ccp.localAnchorA - bodyA.GetLocalCenter()); Vec2 r2 =
   * Mul(bodyB.GetXForm().R, ccp.localAnchorB - bodyB.GetLocalCenter());
   * 
   * Vec2 p1 = bodyA.m_sweep.c + r1; Vec2 p2 = bodyB.m_sweep.c + r2; Vec2 dp = p2 - p1;
   * 
   * // Approximate the current separation. float separation = Dot(dp, normal) + ccp.separation;
   * 
   * // Track max constraint error. minSeparation = Min(minSeparation, separation);
   * 
   * // Prevent large corrections and allow slop. float C = Clamp(baumgarte * (separation +
   * _linearSlop), -_maxLinearCorrection, 0.0f);
   * 
   * // Compute normal impulse float impulse = -ccp.equalizedMass * C;
   * 
   * Vec2 P = impulse * normal;
   * 
   * bodyA.m_sweep.c -= invMassA * P; bodyA.m_sweep.a -= invIA * Cross(r1, P);
   * bodyA.SynchronizeTransform();
   * 
   * bodyB.m_sweep.c += invMassB * P; bodyB.m_sweep.a += invIB * Cross(r2, P);
   * bodyB.SynchronizeTransform(); } }
   * 
   * // We can't expect minSpeparation &gt;= -_linearSlop because we don't // push the separation above
   * -_linearSlop. return minSeparation &gt;= -1.5f * _linearSlop; }
   */

  // djm pooling, and from above
<span class="nc" id="L809">  private final PositionSolverManifold psolver = new PositionSolverManifold();</span>
<span class="nc" id="L810">  private final Vec2 rA = new Vec2();</span>
<span class="nc" id="L811">  private final Vec2 rB = new Vec2();</span>

  /**
   * Sequential solver.
   */
  public final boolean solvePositionConstraints() {
<span class="nc" id="L817">    float minSeparation = 0.0f;</span>

<span class="nc bnc" id="L819" title="All 2 branches missed.">    for (int i = 0; i &lt; m_count; ++i) {</span>
<span class="nc" id="L820">      ContactPositionConstraint pc = m_positionConstraints[i];</span>

<span class="nc" id="L822">      int indexA = pc.indexA;</span>
<span class="nc" id="L823">      int indexB = pc.indexB;</span>

<span class="nc" id="L825">      float mA = pc.invMassA;</span>
<span class="nc" id="L826">      float iA = pc.invIA;</span>
<span class="nc" id="L827">      Vec2 localCenterA = pc.localCenterA;</span>
<span class="nc" id="L828">      float mB = pc.invMassB;</span>
<span class="nc" id="L829">      float iB = pc.invIB;</span>
<span class="nc" id="L830">      Vec2 localCenterB = pc.localCenterB;</span>
<span class="nc" id="L831">      int pointCount = pc.pointCount;</span>

<span class="nc" id="L833">      Vec2 cA = m_positions[indexA].c;</span>
<span class="nc" id="L834">      float aA = m_positions[indexA].a;</span>
<span class="nc" id="L835">      Vec2 cB = m_positions[indexB].c;</span>
<span class="nc" id="L836">      float aB = m_positions[indexB].a;</span>

      // Solve normal constraints
<span class="nc bnc" id="L839" title="All 2 branches missed.">      for (int j = 0; j &lt; pointCount; ++j) {</span>
<span class="nc" id="L840">        xfA.q.set(aA);</span>
<span class="nc" id="L841">        xfB.q.set(aB);</span>
<span class="nc" id="L842">        Rot.mulToOutUnsafe(xfA.q, localCenterA, xfA.p);</span>
<span class="nc" id="L843">        xfA.p.negateLocal().addLocal(cA);</span>
<span class="nc" id="L844">        Rot.mulToOutUnsafe(xfB.q, localCenterB, xfB.p);</span>
<span class="nc" id="L845">        xfB.p.negateLocal().addLocal(cB);</span>

<span class="nc" id="L847">        final PositionSolverManifold psm = psolver;</span>
<span class="nc" id="L848">        psm.initialize(pc, xfA, xfB, j);</span>
<span class="nc" id="L849">        final Vec2 normal = psm.normal;</span>

<span class="nc" id="L851">        final Vec2 point = psm.point;</span>
<span class="nc" id="L852">        final float separation = psm.separation;</span>

<span class="nc" id="L854">        rA.set(point).subLocal(cA);</span>
<span class="nc" id="L855">        rB.set(point).subLocal(cB);</span>

        // Track max constraint error.
<span class="nc" id="L858">        minSeparation = MathUtils.min(minSeparation, separation);</span>

        // Prevent large corrections and allow slop.
<span class="nc" id="L861">        final float C =</span>
<span class="nc" id="L862">            MathUtils.clamp(Settings.baumgarte * (separation + Settings.linearSlop),</span>
                -Settings.maxLinearCorrection, 0.0f);

        // Compute the effective mass.
<span class="nc" id="L866">        final float rnA = Vec2.cross(rA, normal);</span>
<span class="nc" id="L867">        final float rnB = Vec2.cross(rB, normal);</span>
<span class="nc" id="L868">        final float K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;</span>

        // Compute normal impulse
<span class="nc bnc" id="L871" title="All 2 branches missed.">        final float impulse = K &gt; 0.0f ? -C / K : 0.0f;</span>

<span class="nc" id="L873">        P.set(normal).mulLocal(impulse);</span>

<span class="nc" id="L875">        cA.subLocal(temp.set(P).mulLocal(mA));</span>
<span class="nc" id="L876">        aA -= iA * Vec2.cross(rA, P);</span>

<span class="nc" id="L878">        cB.addLocal(temp.set(P).mulLocal(mB));</span>
<span class="nc" id="L879">        aB += iB * Vec2.cross(rB, P);</span>
      }

      // m_positions[indexA].c.set(cA);
<span class="nc" id="L883">      m_positions[indexA].a = aA;</span>

      // m_positions[indexB].c.set(cB);
<span class="nc" id="L886">      m_positions[indexB].a = aB;</span>
    }

    // We can't expect minSpeparation &gt;= -linearSlop because we don't
    // push the separation above -linearSlop.
<span class="nc bnc" id="L891" title="All 2 branches missed.">    return minSeparation &gt;= -3.0f * Settings.linearSlop;</span>
  }

  // Sequential position solver for position constraints.
  public boolean solveTOIPositionConstraints(int toiIndexA, int toiIndexB) {
<span class="nc" id="L896">    float minSeparation = 0.0f;</span>

<span class="nc bnc" id="L898" title="All 2 branches missed.">    for (int i = 0; i &lt; m_count; ++i) {</span>
<span class="nc" id="L899">      ContactPositionConstraint pc = m_positionConstraints[i];</span>

<span class="nc" id="L901">      int indexA = pc.indexA;</span>
<span class="nc" id="L902">      int indexB = pc.indexB;</span>
<span class="nc" id="L903">      Vec2 localCenterA = pc.localCenterA;</span>
<span class="nc" id="L904">      Vec2 localCenterB = pc.localCenterB;</span>
<span class="nc" id="L905">      int pointCount = pc.pointCount;</span>

<span class="nc" id="L907">      float mA = 0.0f;</span>
<span class="nc" id="L908">      float iA = 0.0f;</span>
<span class="nc bnc" id="L909" title="All 4 branches missed.">      if (indexA == toiIndexA || indexA == toiIndexB) {</span>
<span class="nc" id="L910">        mA = pc.invMassA;</span>
<span class="nc" id="L911">        iA = pc.invIA;</span>
      }

<span class="nc" id="L914">      float mB = 0f;</span>
<span class="nc" id="L915">      float iB = 0f;</span>
<span class="nc bnc" id="L916" title="All 4 branches missed.">      if (indexB == toiIndexA || indexB == toiIndexB) {</span>
<span class="nc" id="L917">        mB = pc.invMassB;</span>
<span class="nc" id="L918">        iB = pc.invIB;</span>
      }

<span class="nc" id="L921">      Vec2 cA = m_positions[indexA].c;</span>
<span class="nc" id="L922">      float aA = m_positions[indexA].a;</span>

<span class="nc" id="L924">      Vec2 cB = m_positions[indexB].c;</span>
<span class="nc" id="L925">      float aB = m_positions[indexB].a;</span>

      // Solve normal constraints
<span class="nc bnc" id="L928" title="All 2 branches missed.">      for (int j = 0; j &lt; pointCount; ++j) {</span>
<span class="nc" id="L929">        xfA.q.set(aA);</span>
<span class="nc" id="L930">        xfB.q.set(aB);</span>
<span class="nc" id="L931">        Rot.mulToOutUnsafe(xfA.q, localCenterA, xfA.p);</span>
<span class="nc" id="L932">        xfA.p.negateLocal().addLocal(cA);</span>
<span class="nc" id="L933">        Rot.mulToOutUnsafe(xfB.q, localCenterB, xfB.p);</span>
<span class="nc" id="L934">        xfB.p.negateLocal().addLocal(cB);</span>

<span class="nc" id="L936">        final PositionSolverManifold psm = psolver;</span>
<span class="nc" id="L937">        psm.initialize(pc, xfA, xfB, j);</span>
<span class="nc" id="L938">        Vec2 normal = psm.normal;</span>

<span class="nc" id="L940">        Vec2 point = psm.point;</span>
<span class="nc" id="L941">        float separation = psm.separation;</span>

<span class="nc" id="L943">        rA.set(point).subLocal(cA);</span>
<span class="nc" id="L944">        rB.set(point).subLocal(cB);</span>

        // Track max constraint error.
<span class="nc" id="L947">        minSeparation = MathUtils.min(minSeparation, separation);</span>

        // Prevent large corrections and allow slop.
<span class="nc" id="L950">        float C =</span>
<span class="nc" id="L951">            MathUtils.clamp(Settings.toiBaugarte * (separation + Settings.linearSlop),</span>
                -Settings.maxLinearCorrection, 0.0f);

        // Compute the effective mass.
<span class="nc" id="L955">        float rnA = Vec2.cross(rA, normal);</span>
<span class="nc" id="L956">        float rnB = Vec2.cross(rB, normal);</span>
<span class="nc" id="L957">        float K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;</span>

        // Compute normal impulse
<span class="nc bnc" id="L960" title="All 2 branches missed.">        float impulse = K &gt; 0.0f ? -C / K : 0.0f;</span>

<span class="nc" id="L962">        P.set(normal).mulLocal(impulse);</span>

<span class="nc" id="L964">        cA.subLocal(temp.set(P).mulLocal(mA));</span>
<span class="nc" id="L965">        aA -= iA * Vec2.cross(rA, P);</span>

<span class="nc" id="L967">        cB.addLocal(temp.set(P).mulLocal(mB));</span>
<span class="nc" id="L968">        aB += iB * Vec2.cross(rB, P);</span>
      }

      // m_positions[indexA].c.set(cA);
<span class="nc" id="L972">      m_positions[indexA].a = aA;</span>

      // m_positions[indexB].c.set(cB);
<span class="nc" id="L975">      m_positions[indexB].a = aB;</span>
    }

    // We can't expect minSpeparation &gt;= -_linearSlop because we don't
    // push the separation above -_linearSlop.
<span class="nc bnc" id="L980" title="All 2 branches missed.">    return minSeparation &gt;= -1.5f * Settings.linearSlop;</span>
  }

<span class="nc" id="L983">  public static class ContactSolverDef {</span>
    public TimeStep step;
    public Contact[] contacts;
    public int count;
    public Position[] positions;
    public Velocity[] velocities;
  }
}


<span class="nc bnc" id="L993" title="All 2 branches missed.">class PositionSolverManifold {</span>

<span class="nc" id="L995">  public final Vec2 normal = new Vec2();</span>
<span class="nc" id="L996">  public final Vec2 point = new Vec2();</span>
  public float separation;

  public void initialize(ContactPositionConstraint pc, Transform xfA, Transform xfB, int index) {
<span class="nc bnc" id="L1000" title="All 4 branches missed.">    assert (pc.pointCount &gt; 0);</span>

<span class="nc" id="L1002">    final Rot xfAq = xfA.q;</span>
<span class="nc" id="L1003">    final Rot xfBq = xfB.q;</span>
<span class="nc" id="L1004">    final Vec2 pcLocalPointsI = pc.localPoints[index];</span>
<span class="nc bnc" id="L1005" title="All 4 branches missed.">    switch (pc.type) {</span>
      case CIRCLES: {
        // Transform.mulToOutUnsafe(xfA, pc.localPoint, pointA);
        // Transform.mulToOutUnsafe(xfB, pc.localPoints[0], pointB);
        // normal.set(pointB).subLocal(pointA);
        // normal.normalize();
        //
        // point.set(pointA).addLocal(pointB).mulLocal(.5f);
        // temp.set(pointB).subLocal(pointA);
        // separation = Vec2.dot(temp, normal) - pc.radiusA - pc.radiusB;
<span class="nc" id="L1015">        final Vec2 plocalPoint = pc.localPoint;</span>
<span class="nc" id="L1016">        final Vec2 pLocalPoints0 = pc.localPoints[0];</span>
<span class="nc" id="L1017">        final float pointAx = (xfAq.c * plocalPoint.x - xfAq.s * plocalPoint.y) + xfA.p.x;</span>
<span class="nc" id="L1018">        final float pointAy = (xfAq.s * plocalPoint.x + xfAq.c * plocalPoint.y) + xfA.p.y;</span>
<span class="nc" id="L1019">        final float pointBx = (xfBq.c * pLocalPoints0.x - xfBq.s * pLocalPoints0.y) + xfB.p.x;</span>
<span class="nc" id="L1020">        final float pointBy = (xfBq.s * pLocalPoints0.x + xfBq.c * pLocalPoints0.y) + xfB.p.y;</span>
<span class="nc" id="L1021">        normal.x = pointBx - pointAx;</span>
<span class="nc" id="L1022">        normal.y = pointBy - pointAy;</span>
<span class="nc" id="L1023">        normal.normalize();</span>

<span class="nc" id="L1025">        point.x = (pointAx + pointBx) * .5f;</span>
<span class="nc" id="L1026">        point.y = (pointAy + pointBy) * .5f;</span>
<span class="nc" id="L1027">        final float tempx = pointBx - pointAx;</span>
<span class="nc" id="L1028">        final float tempy = pointBy - pointAy;</span>
<span class="nc" id="L1029">        separation = tempx * normal.x + tempy * normal.y - pc.radiusA - pc.radiusB;</span>
<span class="nc" id="L1030">        break;</span>
      }

      case FACE_A: {
        // Rot.mulToOutUnsafe(xfAq, pc.localNormal, normal);
        // Transform.mulToOutUnsafe(xfA, pc.localPoint, planePoint);
        //
        // Transform.mulToOutUnsafe(xfB, pc.localPoints[index], clipPoint);
        // temp.set(clipPoint).subLocal(planePoint);
        // separation = Vec2.dot(temp, normal) - pc.radiusA - pc.radiusB;
        // point.set(clipPoint);
<span class="nc" id="L1041">        final Vec2 pcLocalNormal = pc.localNormal;</span>
<span class="nc" id="L1042">        final Vec2 pcLocalPoint = pc.localPoint;</span>
<span class="nc" id="L1043">        normal.x = xfAq.c * pcLocalNormal.x - xfAq.s * pcLocalNormal.y;</span>
<span class="nc" id="L1044">        normal.y = xfAq.s * pcLocalNormal.x + xfAq.c * pcLocalNormal.y;</span>
<span class="nc" id="L1045">        final float planePointx = (xfAq.c * pcLocalPoint.x - xfAq.s * pcLocalPoint.y) + xfA.p.x;</span>
<span class="nc" id="L1046">        final float planePointy = (xfAq.s * pcLocalPoint.x + xfAq.c * pcLocalPoint.y) + xfA.p.y;</span>

<span class="nc" id="L1048">        final float clipPointx = (xfBq.c * pcLocalPointsI.x - xfBq.s * pcLocalPointsI.y) + xfB.p.x;</span>
<span class="nc" id="L1049">        final float clipPointy = (xfBq.s * pcLocalPointsI.x + xfBq.c * pcLocalPointsI.y) + xfB.p.y;</span>
<span class="nc" id="L1050">        final float tempx = clipPointx - planePointx;</span>
<span class="nc" id="L1051">        final float tempy = clipPointy - planePointy;</span>
<span class="nc" id="L1052">        separation = tempx * normal.x + tempy * normal.y - pc.radiusA - pc.radiusB;</span>
<span class="nc" id="L1053">        point.x = clipPointx;</span>
<span class="nc" id="L1054">        point.y = clipPointy;</span>
<span class="nc" id="L1055">        break;</span>
      }

      case FACE_B: {
        // Rot.mulToOutUnsafe(xfBq, pc.localNormal, normal);
        // Transform.mulToOutUnsafe(xfB, pc.localPoint, planePoint);
        //
        // Transform.mulToOutUnsafe(xfA, pcLocalPointsI, clipPoint);
        // temp.set(clipPoint).subLocal(planePoint);
        // separation = Vec2.dot(temp, normal) - pc.radiusA - pc.radiusB;
        // point.set(clipPoint);
        //
        // // Ensure normal points from A to B
        // normal.negateLocal();
<span class="nc" id="L1069">        final Vec2 pcLocalNormal = pc.localNormal;</span>
<span class="nc" id="L1070">        final Vec2 pcLocalPoint = pc.localPoint;</span>
<span class="nc" id="L1071">        normal.x = xfBq.c * pcLocalNormal.x - xfBq.s * pcLocalNormal.y;</span>
<span class="nc" id="L1072">        normal.y = xfBq.s * pcLocalNormal.x + xfBq.c * pcLocalNormal.y;</span>
<span class="nc" id="L1073">        final float planePointx = (xfBq.c * pcLocalPoint.x - xfBq.s * pcLocalPoint.y) + xfB.p.x;</span>
<span class="nc" id="L1074">        final float planePointy = (xfBq.s * pcLocalPoint.x + xfBq.c * pcLocalPoint.y) + xfB.p.y;</span>

<span class="nc" id="L1076">        final float clipPointx = (xfAq.c * pcLocalPointsI.x - xfAq.s * pcLocalPointsI.y) + xfA.p.x;</span>
<span class="nc" id="L1077">        final float clipPointy = (xfAq.s * pcLocalPointsI.x + xfAq.c * pcLocalPointsI.y) + xfA.p.y;</span>
<span class="nc" id="L1078">        final float tempx = clipPointx - planePointx;</span>
<span class="nc" id="L1079">        final float tempy = clipPointy - planePointy;</span>
<span class="nc" id="L1080">        separation = tempx * normal.x + tempy * normal.y - pc.radiusA - pc.radiusB;</span>
<span class="nc" id="L1081">        point.x = clipPointx;</span>
<span class="nc" id="L1082">        point.y = clipPointy;</span>
<span class="nc" id="L1083">        normal.x *= -1;</span>
<span class="nc" id="L1084">        normal.y *= -1;</span>
      }
        break;
    }
<span class="nc" id="L1088">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>