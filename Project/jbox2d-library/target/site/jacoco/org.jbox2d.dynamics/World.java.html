<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>World.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jbox2d-library</a> &gt; <a href="index.source.html" class="el_package">org.jbox2d.dynamics</a> &gt; <span class="el_source">World.java</span></div><h1>World.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2013, Daniel Murphy
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 	* Redistributions of source code must retain the above copyright notice,
 * 	  this list of conditions and the following disclaimer.
 * 	* Redistributions in binary form must reproduce the above copyright notice,
 * 	  this list of conditions and the following disclaimer in the documentation
 * 	  and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************/
package org.jbox2d.dynamics;

import org.jbox2d.callbacks.ContactFilter;
import org.jbox2d.callbacks.ContactListener;
import org.jbox2d.callbacks.DebugDraw;
import org.jbox2d.callbacks.DestructionListener;
import org.jbox2d.callbacks.QueryCallback;
import org.jbox2d.callbacks.RayCastCallback;
import org.jbox2d.callbacks.TreeCallback;
import org.jbox2d.callbacks.TreeRayCastCallback;
import org.jbox2d.collision.AABB;
import org.jbox2d.collision.RayCastInput;
import org.jbox2d.collision.RayCastOutput;
import org.jbox2d.collision.TimeOfImpact.TOIInput;
import org.jbox2d.collision.TimeOfImpact.TOIOutput;
import org.jbox2d.collision.TimeOfImpact.TOIOutputState;
import org.jbox2d.collision.broadphase.BroadPhase;
import org.jbox2d.collision.broadphase.BroadPhaseStrategy;
import org.jbox2d.collision.broadphase.DynamicTree;
import org.jbox2d.collision.shapes.ChainShape;
import org.jbox2d.collision.shapes.CircleShape;
import org.jbox2d.collision.shapes.EdgeShape;
import org.jbox2d.collision.shapes.PolygonShape;
import org.jbox2d.collision.shapes.ShapeType;
import org.jbox2d.common.Color3f;
import org.jbox2d.common.MathUtils;
import org.jbox2d.common.Settings;
import org.jbox2d.common.Sweep;
import org.jbox2d.common.Timer;
import org.jbox2d.common.Transform;
import org.jbox2d.common.Vec2;
import org.jbox2d.dynamics.contacts.Contact;
import org.jbox2d.dynamics.contacts.ContactEdge;
import org.jbox2d.dynamics.contacts.ContactRegister;
import org.jbox2d.dynamics.joints.Joint;
import org.jbox2d.dynamics.joints.JointDef;
import org.jbox2d.dynamics.joints.JointEdge;
import org.jbox2d.dynamics.joints.PulleyJoint;
import org.jbox2d.pooling.IDynamicStack;
import org.jbox2d.pooling.IWorldPool;
import org.jbox2d.pooling.arrays.Vec2Array;
import org.jbox2d.pooling.normal.DefaultWorldPool;

/**
 * The world class manages all physics entities, dynamic simulation, and asynchronous queries. The
 * world also contains efficient memory management facilities.
 * 
 * @author Daniel Murphy
 */
<span class="nc bnc" id="L73" title="All 2 branches missed.">public class World {</span>
  public static final int WORLD_POOL_SIZE = 100;
  public static final int WORLD_POOL_CONTAINER_SIZE = 10;

  public static final int NEW_FIXTURE = 0x0001;
  public static final int LOCKED = 0x0002;
  public static final int CLEAR_FORCES = 0x0004;


  // statistics gathering
<span class="nc" id="L83">  public int activeContacts = 0;</span>
<span class="nc" id="L84">  public int contactPoolCount = 0;</span>

  protected int m_flags;

  protected ContactManager m_contactManager;

  private Body m_bodyList;
  private Joint m_jointList;

  private int m_bodyCount;
  private int m_jointCount;

<span class="nc" id="L96">  private final Vec2 m_gravity = new Vec2();</span>
  private boolean m_allowSleep;

  // private Body m_groundBody;

  private DestructionListener m_destructionListener;
  private DebugDraw m_debugDraw;

  private final IWorldPool pool;

  /**
   * This is used to compute the time step ratio to support a variable time step.
   */
  private float m_inv_dt0;

  // these are for debugging the solver
  private boolean m_warmStarting;
  private boolean m_continuousPhysics;
  private boolean m_subStepping;

  private boolean m_stepComplete;

  private Profile m_profile;


<span class="nc" id="L121">  private ContactRegister[][] contactStacks =</span>
<span class="nc" id="L122">      new ContactRegister[ShapeType.values().length][ShapeType.values().length];</span>

  /**
   * Construct a world object.
   * 
   * @param gravity the world gravity vector.
   */
  public World(Vec2 gravity) {
<span class="nc" id="L130">    this(gravity, new DefaultWorldPool(WORLD_POOL_SIZE, WORLD_POOL_CONTAINER_SIZE));</span>
<span class="nc" id="L131">  }</span>

  /**
   * Construct a world object.
   * 
   * @param gravity the world gravity vector.
   */
  public World(Vec2 gravity, IWorldPool pool) {
<span class="nc" id="L139">    this(gravity, pool, new DynamicTree());</span>
<span class="nc" id="L140">  }</span>
  
<span class="nc" id="L142">  public World(Vec2 gravity, IWorldPool argPool, BroadPhaseStrategy broadPhaseStrategy) {</span>
<span class="nc" id="L143">    pool = argPool;</span>
<span class="nc" id="L144">    m_destructionListener = null;</span>
<span class="nc" id="L145">    m_debugDraw = null;</span>

<span class="nc" id="L147">    m_bodyList = null;</span>
<span class="nc" id="L148">    m_jointList = null;</span>

<span class="nc" id="L150">    m_bodyCount = 0;</span>
<span class="nc" id="L151">    m_jointCount = 0;</span>

<span class="nc" id="L153">    m_warmStarting = true;</span>
<span class="nc" id="L154">    m_continuousPhysics = true;</span>
<span class="nc" id="L155">    m_subStepping = false;</span>
<span class="nc" id="L156">    m_stepComplete = true;</span>

<span class="nc" id="L158">    m_allowSleep = true;</span>
<span class="nc" id="L159">    m_gravity.set(gravity);</span>

<span class="nc" id="L161">    m_flags = CLEAR_FORCES;</span>

<span class="nc" id="L163">    m_inv_dt0 = 0f;</span>

<span class="nc" id="L165">    m_contactManager = new ContactManager(this, broadPhaseStrategy);</span>
<span class="nc" id="L166">    m_profile = new Profile();</span>

<span class="nc" id="L168">    initializeRegisters();</span>
<span class="nc" id="L169">  }</span>

  public void setAllowSleep(boolean flag) {
<span class="nc bnc" id="L172" title="All 2 branches missed.">    if (flag == m_allowSleep) {</span>
<span class="nc" id="L173">      return;</span>
    }

<span class="nc" id="L176">    m_allowSleep = flag;</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">    if (m_allowSleep == false) {</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">      for (Body b = m_bodyList; b != null; b = b.m_next) {</span>
<span class="nc" id="L179">        b.setAwake(true);</span>
      }
    }
<span class="nc" id="L182">  }</span>
  
  public void setSubStepping(boolean subStepping) {
<span class="nc" id="L185">    this.m_subStepping = subStepping;</span>
<span class="nc" id="L186">  }</span>

  public boolean isSubStepping() {
<span class="nc" id="L189">    return m_subStepping;</span>
  }
  
  public boolean isAllowSleep() {
<span class="nc" id="L193">    return m_allowSleep;</span>
  }

  private void addType(IDynamicStack&lt;Contact&gt; creator, ShapeType type1, ShapeType type2) {
<span class="nc" id="L197">    ContactRegister register = new ContactRegister();</span>
<span class="nc" id="L198">    register.creator = creator;</span>
<span class="nc" id="L199">    register.primary = true;</span>
<span class="nc" id="L200">    contactStacks[type1.ordinal()][type2.ordinal()] = register;</span>

<span class="nc bnc" id="L202" title="All 2 branches missed.">    if (type1 != type2) {</span>
<span class="nc" id="L203">      ContactRegister register2 = new ContactRegister();</span>
<span class="nc" id="L204">      register2.creator = creator;</span>
<span class="nc" id="L205">      register2.primary = false;</span>
<span class="nc" id="L206">      contactStacks[type2.ordinal()][type1.ordinal()] = register2;</span>
    }
<span class="nc" id="L208">  }</span>

  private void initializeRegisters() {
<span class="nc" id="L211">    addType(pool.getCircleContactStack(), ShapeType.CIRCLE, ShapeType.CIRCLE);</span>
<span class="nc" id="L212">    addType(pool.getPolyCircleContactStack(), ShapeType.POLYGON, ShapeType.CIRCLE);</span>
<span class="nc" id="L213">    addType(pool.getPolyContactStack(), ShapeType.POLYGON, ShapeType.POLYGON);</span>
<span class="nc" id="L214">    addType(pool.getEdgeCircleContactStack(), ShapeType.EDGE, ShapeType.CIRCLE);</span>
<span class="nc" id="L215">    addType(pool.getEdgePolyContactStack(), ShapeType.EDGE, ShapeType.POLYGON);</span>
<span class="nc" id="L216">    addType(pool.getChainCircleContactStack(), ShapeType.CHAIN, ShapeType.CIRCLE);</span>
<span class="nc" id="L217">    addType(pool.getChainPolyContactStack(), ShapeType.CHAIN, ShapeType.POLYGON);</span>
<span class="nc" id="L218">  }</span>

  public Contact popContact(Fixture fixtureA, int indexA, Fixture fixtureB, int indexB) {
<span class="nc" id="L221">    final ShapeType type1 = fixtureA.getType();</span>
<span class="nc" id="L222">    final ShapeType type2 = fixtureB.getType();</span>

<span class="nc" id="L224">    final ContactRegister reg = contactStacks[type1.ordinal()][type2.ordinal()];</span>
<span class="nc" id="L225">    final IDynamicStack&lt;Contact&gt; creator = reg.creator;</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">    if (creator != null) {</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">      if (reg.primary) {</span>
<span class="nc" id="L228">        Contact c = creator.pop();</span>
<span class="nc" id="L229">        c.init(fixtureA, indexA, fixtureB, indexB);</span>
<span class="nc" id="L230">        return c;</span>
      } else {
<span class="nc" id="L232">        Contact c = creator.pop();</span>
<span class="nc" id="L233">        c.init(fixtureB, indexB, fixtureA, indexA);</span>
<span class="nc" id="L234">        return c;</span>
      }
    } else {
<span class="nc" id="L237">      return null;</span>
    }
  }

  public void pushContact(Contact contact) {
<span class="nc" id="L242">    Fixture fixtureA = contact.getFixtureA();</span>
<span class="nc" id="L243">    Fixture fixtureB = contact.getFixtureB();</span>
    
<span class="nc bnc" id="L245" title="All 6 branches missed.">    if (contact.m_manifold.pointCount &gt; 0 &amp;&amp; !fixtureA.isSensor() &amp;&amp; !fixtureB.isSensor()) {</span>
<span class="nc" id="L246">      fixtureA.getBody().setAwake(true);</span>
<span class="nc" id="L247">      fixtureB.getBody().setAwake(true);</span>
    }

<span class="nc" id="L250">    ShapeType type1 = fixtureA.getType();</span>
<span class="nc" id="L251">    ShapeType type2 = fixtureB.getType();</span>

<span class="nc" id="L253">    IDynamicStack&lt;Contact&gt; creator = contactStacks[type1.ordinal()][type2.ordinal()].creator;</span>
<span class="nc" id="L254">    creator.push(contact);</span>
<span class="nc" id="L255">  }</span>

  public IWorldPool getPool() {
<span class="nc" id="L258">    return pool;</span>
  }

  /**
   * Register a destruction listener. The listener is owned by you and must remain in scope.
   * 
   * @param listener
   */
  public void setDestructionListener(DestructionListener listener) {
<span class="nc" id="L267">    m_destructionListener = listener;</span>
<span class="nc" id="L268">  }</span>

  /**
   * Register a contact filter to provide specific control over collision. Otherwise the default
   * filter is used (_defaultFilter). The listener is owned by you and must remain in scope.
   * 
   * @param filter
   */
  public void setContactFilter(ContactFilter filter) {
<span class="nc" id="L277">    m_contactManager.m_contactFilter = filter;</span>
<span class="nc" id="L278">  }</span>

  /**
   * Register a contact event listener. The listener is owned by you and must remain in scope.
   * 
   * @param listener
   */
  public void setContactListener(ContactListener listener) {
<span class="nc" id="L286">    m_contactManager.m_contactListener = listener;</span>
<span class="nc" id="L287">  }</span>

  /**
   * Register a routine for debug drawing. The debug draw functions are called inside with
   * World.DrawDebugData method. The debug draw object is owned by you and must remain in scope.
   * 
   * @param debugDraw
   */
  public void setDebugDraw(DebugDraw debugDraw) {
<span class="nc" id="L296">    m_debugDraw = debugDraw;</span>
<span class="nc" id="L297">  }</span>

  /**
   * create a rigid body given a definition. No reference to the definition is retained.
   * 
   * @warning This function is locked during callbacks.
   * @param def
   * @return
   */
  public Body createBody(BodyDef def) {
<span class="nc bnc" id="L307" title="All 4 branches missed.">    assert (isLocked() == false);</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">    if (isLocked()) {</span>
<span class="nc" id="L309">      return null;</span>
    }
    // TODO djm pooling
<span class="nc" id="L312">    Body b = new Body(def, this);</span>

    // add to world doubly linked list
<span class="nc" id="L315">    b.m_prev = null;</span>
<span class="nc" id="L316">    b.m_next = m_bodyList;</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">    if (m_bodyList != null) {</span>
<span class="nc" id="L318">      m_bodyList.m_prev = b;</span>
    }
<span class="nc" id="L320">    m_bodyList = b;</span>
<span class="nc" id="L321">    ++m_bodyCount;</span>

<span class="nc" id="L323">    return b;</span>
  }

  /**
   * destroy a rigid body given a definition. No reference to the definition is retained. This
   * function is locked during callbacks.
   * 
   * @warning This automatically deletes all associated shapes and joints.
   * @warning This function is locked during callbacks.
   * @param body
   */
  public void destroyBody(Body body) {
<span class="nc bnc" id="L335" title="All 4 branches missed.">    assert (m_bodyCount &gt; 0);</span>
<span class="nc bnc" id="L336" title="All 4 branches missed.">    assert (isLocked() == false);</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">    if (isLocked()) {</span>
<span class="nc" id="L338">      return;</span>
    }

    // Delete the attached joints.
<span class="nc" id="L342">    JointEdge je = body.m_jointList;</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">    while (je != null) {</span>
<span class="nc" id="L344">      JointEdge je0 = je;</span>
<span class="nc" id="L345">      je = je.next;</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">      if (m_destructionListener != null) {</span>
<span class="nc" id="L347">        m_destructionListener.sayGoodbye(je0.joint);</span>
      }

<span class="nc" id="L350">      destroyJoint(je0.joint);</span>

<span class="nc" id="L352">      body.m_jointList = je;</span>
<span class="nc" id="L353">    }</span>
<span class="nc" id="L354">    body.m_jointList = null;</span>

    // Delete the attached contacts.
<span class="nc" id="L357">    ContactEdge ce = body.m_contactList;</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">    while (ce != null) {</span>
<span class="nc" id="L359">      ContactEdge ce0 = ce;</span>
<span class="nc" id="L360">      ce = ce.next;</span>
<span class="nc" id="L361">      m_contactManager.destroy(ce0.contact);</span>
<span class="nc" id="L362">    }</span>
<span class="nc" id="L363">    body.m_contactList = null;</span>

<span class="nc" id="L365">    Fixture f = body.m_fixtureList;</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">    while (f != null) {</span>
<span class="nc" id="L367">      Fixture f0 = f;</span>
<span class="nc" id="L368">      f = f.m_next;</span>

<span class="nc bnc" id="L370" title="All 2 branches missed.">      if (m_destructionListener != null) {</span>
<span class="nc" id="L371">        m_destructionListener.sayGoodbye(f0);</span>
      }

<span class="nc" id="L374">      f0.destroyProxies(m_contactManager.m_broadPhase);</span>
<span class="nc" id="L375">      f0.destroy();</span>
      // TODO djm recycle fixtures (here or in that destroy method)
<span class="nc" id="L377">      body.m_fixtureList = f;</span>
<span class="nc" id="L378">      body.m_fixtureCount -= 1;</span>
<span class="nc" id="L379">    }</span>
<span class="nc" id="L380">    body.m_fixtureList = null;</span>
<span class="nc" id="L381">    body.m_fixtureCount = 0;</span>

    // Remove world body list.
<span class="nc bnc" id="L384" title="All 2 branches missed.">    if (body.m_prev != null) {</span>
<span class="nc" id="L385">      body.m_prev.m_next = body.m_next;</span>
    }

<span class="nc bnc" id="L388" title="All 2 branches missed.">    if (body.m_next != null) {</span>
<span class="nc" id="L389">      body.m_next.m_prev = body.m_prev;</span>
    }

<span class="nc bnc" id="L392" title="All 2 branches missed.">    if (body == m_bodyList) {</span>
<span class="nc" id="L393">      m_bodyList = body.m_next;</span>
    }

<span class="nc" id="L396">    --m_bodyCount;</span>
    // TODO djm recycle body
<span class="nc" id="L398">  }</span>

  /**
   * create a joint to constrain bodies together. No reference to the definition is retained. This
   * may cause the connected bodies to cease colliding.
   * 
   * @warning This function is locked during callbacks.
   * @param def
   * @return
   */
  public Joint createJoint(JointDef def) {
<span class="nc bnc" id="L409" title="All 4 branches missed.">    assert (isLocked() == false);</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">    if (isLocked()) {</span>
<span class="nc" id="L411">      return null;</span>
    }

<span class="nc" id="L414">    Joint j = Joint.create(this, def);</span>

    // Connect to the world list.
<span class="nc" id="L417">    j.m_prev = null;</span>
<span class="nc" id="L418">    j.m_next = m_jointList;</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">    if (m_jointList != null) {</span>
<span class="nc" id="L420">      m_jointList.m_prev = j;</span>
    }
<span class="nc" id="L422">    m_jointList = j;</span>
<span class="nc" id="L423">    ++m_jointCount;</span>

    // Connect to the bodies' doubly linked lists.
<span class="nc" id="L426">    j.m_edgeA.joint = j;</span>
<span class="nc" id="L427">    j.m_edgeA.other = j.getBodyB();</span>
<span class="nc" id="L428">    j.m_edgeA.prev = null;</span>
<span class="nc" id="L429">    j.m_edgeA.next = j.getBodyA().m_jointList;</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">    if (j.getBodyA().m_jointList != null) {</span>
<span class="nc" id="L431">      j.getBodyA().m_jointList.prev = j.m_edgeA;</span>
    }
<span class="nc" id="L433">    j.getBodyA().m_jointList = j.m_edgeA;</span>

<span class="nc" id="L435">    j.m_edgeB.joint = j;</span>
<span class="nc" id="L436">    j.m_edgeB.other = j.getBodyA();</span>
<span class="nc" id="L437">    j.m_edgeB.prev = null;</span>
<span class="nc" id="L438">    j.m_edgeB.next = j.getBodyB().m_jointList;</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">    if (j.getBodyB().m_jointList != null) {</span>
<span class="nc" id="L440">      j.getBodyB().m_jointList.prev = j.m_edgeB;</span>
    }
<span class="nc" id="L442">    j.getBodyB().m_jointList = j.m_edgeB;</span>

<span class="nc" id="L444">    Body bodyA = def.bodyA;</span>
<span class="nc" id="L445">    Body bodyB = def.bodyB;</span>

    // If the joint prevents collisions, then flag any contacts for filtering.
<span class="nc bnc" id="L448" title="All 2 branches missed.">    if (def.collideConnected == false) {</span>
<span class="nc" id="L449">      ContactEdge edge = bodyB.getContactList();</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">      while (edge != null) {</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">        if (edge.other == bodyA) {</span>
          // Flag the contact for filtering at the next time step (where either
          // body is awake).
<span class="nc" id="L454">          edge.contact.flagForFiltering();</span>
        }

<span class="nc" id="L457">        edge = edge.next;</span>
      }
    }

    // Note: creating a joint doesn't wake the bodies.

<span class="nc" id="L463">    return j;</span>
  }

  /**
   * destroy a joint. This may cause the connected bodies to begin colliding.
   * 
   * @warning This function is locked during callbacks.
   * @param joint
   */
  public void destroyJoint(Joint j) {
<span class="nc bnc" id="L473" title="All 4 branches missed.">    assert (isLocked() == false);</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">    if (isLocked()) {</span>
<span class="nc" id="L475">      return;</span>
    }

<span class="nc" id="L478">    boolean collideConnected = j.getCollideConnected();</span>

    // Remove from the doubly linked list.
<span class="nc bnc" id="L481" title="All 2 branches missed.">    if (j.m_prev != null) {</span>
<span class="nc" id="L482">      j.m_prev.m_next = j.m_next;</span>
    }

<span class="nc bnc" id="L485" title="All 2 branches missed.">    if (j.m_next != null) {</span>
<span class="nc" id="L486">      j.m_next.m_prev = j.m_prev;</span>
    }

<span class="nc bnc" id="L489" title="All 2 branches missed.">    if (j == m_jointList) {</span>
<span class="nc" id="L490">      m_jointList = j.m_next;</span>
    }

    // Disconnect from island graph.
<span class="nc" id="L494">    Body bodyA = j.getBodyA();</span>
<span class="nc" id="L495">    Body bodyB = j.getBodyB();</span>

    // Wake up connected bodies.
<span class="nc" id="L498">    bodyA.setAwake(true);</span>
<span class="nc" id="L499">    bodyB.setAwake(true);</span>

    // Remove from body 1.
<span class="nc bnc" id="L502" title="All 2 branches missed.">    if (j.m_edgeA.prev != null) {</span>
<span class="nc" id="L503">      j.m_edgeA.prev.next = j.m_edgeA.next;</span>
    }

<span class="nc bnc" id="L506" title="All 2 branches missed.">    if (j.m_edgeA.next != null) {</span>
<span class="nc" id="L507">      j.m_edgeA.next.prev = j.m_edgeA.prev;</span>
    }

<span class="nc bnc" id="L510" title="All 2 branches missed.">    if (j.m_edgeA == bodyA.m_jointList) {</span>
<span class="nc" id="L511">      bodyA.m_jointList = j.m_edgeA.next;</span>
    }

<span class="nc" id="L514">    j.m_edgeA.prev = null;</span>
<span class="nc" id="L515">    j.m_edgeA.next = null;</span>

    // Remove from body 2
<span class="nc bnc" id="L518" title="All 2 branches missed.">    if (j.m_edgeB.prev != null) {</span>
<span class="nc" id="L519">      j.m_edgeB.prev.next = j.m_edgeB.next;</span>
    }

<span class="nc bnc" id="L522" title="All 2 branches missed.">    if (j.m_edgeB.next != null) {</span>
<span class="nc" id="L523">      j.m_edgeB.next.prev = j.m_edgeB.prev;</span>
    }

<span class="nc bnc" id="L526" title="All 2 branches missed.">    if (j.m_edgeB == bodyB.m_jointList) {</span>
<span class="nc" id="L527">      bodyB.m_jointList = j.m_edgeB.next;</span>
    }

<span class="nc" id="L530">    j.m_edgeB.prev = null;</span>
<span class="nc" id="L531">    j.m_edgeB.next = null;</span>

<span class="nc" id="L533">    Joint.destroy(j);</span>

<span class="nc bnc" id="L535" title="All 4 branches missed.">    assert (m_jointCount &gt; 0);</span>
<span class="nc" id="L536">    --m_jointCount;</span>

    // If the joint prevents collisions, then flag any contacts for filtering.
<span class="nc bnc" id="L539" title="All 2 branches missed.">    if (collideConnected == false) {</span>
<span class="nc" id="L540">      ContactEdge edge = bodyB.getContactList();</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">      while (edge != null) {</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">        if (edge.other == bodyA) {</span>
          // Flag the contact for filtering at the next time step (where either
          // body is awake).
<span class="nc" id="L545">          edge.contact.flagForFiltering();</span>
        }

<span class="nc" id="L548">        edge = edge.next;</span>
      }
    }
<span class="nc" id="L551">  }</span>

  // djm pooling
<span class="nc" id="L554">  private final TimeStep step = new TimeStep();</span>
<span class="nc" id="L555">  private final Timer stepTimer = new Timer();</span>
<span class="nc" id="L556">  private final Timer tempTimer = new Timer();</span>

  /**
   * Take a time step. This performs collision detection, integration, and constraint solution.
   * 
   * @param timeStep the amount of time to simulate, this should not vary.
   * @param velocityIterations for the velocity constraint solver.
   * @param positionIterations for the position constraint solver.
   */
  public void step(float dt, int velocityIterations, int positionIterations) {
<span class="nc" id="L566">    stepTimer.reset();</span>
    // log.debug(&quot;Starting step&quot;);
    // If new fixtures were added, we need to find the new contacts.
<span class="nc bnc" id="L569" title="All 2 branches missed.">    if ((m_flags &amp; NEW_FIXTURE) == NEW_FIXTURE) {</span>
      // log.debug(&quot;There's a new fixture, lets look for new contacts&quot;);
<span class="nc" id="L571">      m_contactManager.findNewContacts();</span>
<span class="nc" id="L572">      m_flags &amp;= ~NEW_FIXTURE;</span>
    }

<span class="nc" id="L575">    m_flags |= LOCKED;</span>

<span class="nc" id="L577">    step.dt = dt;</span>
<span class="nc" id="L578">    step.velocityIterations = velocityIterations;</span>
<span class="nc" id="L579">    step.positionIterations = positionIterations;</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">    if (dt &gt; 0.0f) {</span>
<span class="nc" id="L581">      step.inv_dt = 1.0f / dt;</span>
    } else {
<span class="nc" id="L583">      step.inv_dt = 0.0f;</span>
    }

<span class="nc" id="L586">    step.dtRatio = m_inv_dt0 * dt;</span>

<span class="nc" id="L588">    step.warmStarting = m_warmStarting;</span>

    // Update contacts. This is where some contacts are destroyed.
<span class="nc" id="L591">    tempTimer.reset();</span>
<span class="nc" id="L592">    m_contactManager.collide();</span>
<span class="nc" id="L593">    m_profile.collide = tempTimer.getMilliseconds();</span>

    // Integrate velocities, solve velocity constraints, and integrate positions.
<span class="nc bnc" id="L596" title="All 4 branches missed.">    if (m_stepComplete &amp;&amp; step.dt &gt; 0.0f) {</span>
<span class="nc" id="L597">      tempTimer.reset();</span>
<span class="nc" id="L598">      solve(step);</span>
<span class="nc" id="L599">      m_profile.solve = tempTimer.getMilliseconds();</span>
    }

    // Handle TOI events.
<span class="nc bnc" id="L603" title="All 4 branches missed.">    if (m_continuousPhysics &amp;&amp; step.dt &gt; 0.0f) {</span>
<span class="nc" id="L604">      tempTimer.reset();</span>
<span class="nc" id="L605">      solveTOI(step);</span>
<span class="nc" id="L606">      m_profile.solveTOI = tempTimer.getMilliseconds();</span>
    }

<span class="nc bnc" id="L609" title="All 2 branches missed.">    if (step.dt &gt; 0.0f) {</span>
<span class="nc" id="L610">      m_inv_dt0 = step.inv_dt;</span>
    }

<span class="nc bnc" id="L613" title="All 2 branches missed.">    if ((m_flags &amp; CLEAR_FORCES) == CLEAR_FORCES) {</span>
<span class="nc" id="L614">      clearForces();</span>
    }

<span class="nc" id="L617">    m_flags &amp;= ~LOCKED;</span>
    // log.debug(&quot;ending step&quot;);

<span class="nc" id="L620">    m_profile.step = stepTimer.getMilliseconds();</span>
<span class="nc" id="L621">  }</span>

  /**
   * Call this after you are done with time steps to clear the forces. You normally call this after
   * each call to Step, unless you are performing sub-steps. By default, forces will be
   * automatically cleared, so you don't need to call this function.
   * 
   * @see setAutoClearForces
   */
  public void clearForces() {
<span class="nc bnc" id="L631" title="All 2 branches missed.">    for (Body body = m_bodyList; body != null; body = body.getNext()) {</span>
<span class="nc" id="L632">      body.m_force.setZero();</span>
<span class="nc" id="L633">      body.m_torque = 0.0f;</span>
    }
<span class="nc" id="L635">  }</span>

<span class="nc" id="L637">  private final Color3f color = new Color3f();</span>
<span class="nc" id="L638">  private final Transform xf = new Transform();</span>
<span class="nc" id="L639">  private final Vec2 cA = new Vec2();</span>
<span class="nc" id="L640">  private final Vec2 cB = new Vec2();</span>
<span class="nc" id="L641">  private final Vec2Array avs = new Vec2Array();</span>

  /**
   * Call this to draw shapes and other debug draw data.
   */
  public void drawDebugData() {
<span class="nc bnc" id="L647" title="All 2 branches missed.">    if (m_debugDraw == null) {</span>
<span class="nc" id="L648">      return;</span>
    }

<span class="nc" id="L651">    int flags = m_debugDraw.getFlags();</span>

<span class="nc bnc" id="L653" title="All 2 branches missed.">    if ((flags &amp; DebugDraw.e_shapeBit) == DebugDraw.e_shapeBit) {</span>
<span class="nc bnc" id="L654" title="All 2 branches missed.">      for (Body b = m_bodyList; b != null; b = b.getNext()) {</span>
<span class="nc" id="L655">        xf.set(b.getTransform());</span>
<span class="nc bnc" id="L656" title="All 2 branches missed.">        for (Fixture f = b.getFixtureList(); f != null; f = f.getNext()) {</span>
<span class="nc bnc" id="L657" title="All 2 branches missed.">          if (b.isActive() == false) {</span>
<span class="nc" id="L658">            color.set(0.5f, 0.5f, 0.3f);</span>
<span class="nc" id="L659">            drawShape(f, xf, color);</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">          } else if (b.getType() == BodyType.STATIC) {</span>
<span class="nc" id="L661">            color.set(0.5f, 0.9f, 0.3f);</span>
<span class="nc" id="L662">            drawShape(f, xf, color);</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">          } else if (b.getType() == BodyType.KINEMATIC) {</span>
<span class="nc" id="L664">            color.set(0.5f, 0.5f, 0.9f);</span>
<span class="nc" id="L665">            drawShape(f, xf, color);</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">          } else if (b.isAwake() == false) {</span>
<span class="nc" id="L667">            color.set(0.5f, 0.5f, 0.5f);</span>
<span class="nc" id="L668">            drawShape(f, xf, color);</span>
          } else {
<span class="nc" id="L670">            color.set(0.9f, 0.7f, 0.7f);</span>
<span class="nc" id="L671">            drawShape(f, xf, color);</span>
          }
        }
      }
    }

<span class="nc bnc" id="L677" title="All 2 branches missed.">    if ((flags &amp; DebugDraw.e_jointBit) == DebugDraw.e_jointBit) {</span>
<span class="nc bnc" id="L678" title="All 2 branches missed.">      for (Joint j = m_jointList; j != null; j = j.getNext()) {</span>
<span class="nc" id="L679">        drawJoint(j);</span>
      }
    }

<span class="nc bnc" id="L683" title="All 2 branches missed.">    if ((flags &amp; DebugDraw.e_pairBit) == DebugDraw.e_pairBit) {</span>
<span class="nc" id="L684">      color.set(0.3f, 0.9f, 0.9f);</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">      for (Contact c = m_contactManager.m_contactList; c != null; c = c.getNext()) {</span>
<span class="nc" id="L686">        Fixture fixtureA = c.getFixtureA();</span>
<span class="nc" id="L687">        Fixture fixtureB = c.getFixtureB();</span>
<span class="nc" id="L688">        fixtureA.getAABB(c.getChildIndexA()).getCenterToOut(cA);</span>
<span class="nc" id="L689">        fixtureB.getAABB(c.getChildIndexB()).getCenterToOut(cB);</span>
<span class="nc" id="L690">        m_debugDraw.drawSegment(cA, cB, color);</span>
      }
    }

<span class="nc bnc" id="L694" title="All 2 branches missed.">    if ((flags &amp; DebugDraw.e_aabbBit) == DebugDraw.e_aabbBit) {</span>
<span class="nc" id="L695">      color.set(0.9f, 0.3f, 0.9f);</span>

<span class="nc bnc" id="L697" title="All 2 branches missed.">      for (Body b = m_bodyList; b != null; b = b.getNext()) {</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">        if (b.isActive() == false) {</span>
<span class="nc" id="L699">          continue;</span>
        }

<span class="nc bnc" id="L702" title="All 2 branches missed.">        for (Fixture f = b.getFixtureList(); f != null; f = f.getNext()) {</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">          for (int i = 0; i &lt; f.m_proxyCount; ++i) {</span>
<span class="nc" id="L704">            FixtureProxy proxy = f.m_proxies[i];</span>
<span class="nc" id="L705">            AABB aabb = m_contactManager.m_broadPhase.getFatAABB(proxy.proxyId);</span>
<span class="nc" id="L706">            Vec2[] vs = avs.get(4);</span>
<span class="nc" id="L707">            vs[0].set(aabb.lowerBound.x, aabb.lowerBound.y);</span>
<span class="nc" id="L708">            vs[1].set(aabb.upperBound.x, aabb.lowerBound.y);</span>
<span class="nc" id="L709">            vs[2].set(aabb.upperBound.x, aabb.upperBound.y);</span>
<span class="nc" id="L710">            vs[3].set(aabb.lowerBound.x, aabb.upperBound.y);</span>
<span class="nc" id="L711">            m_debugDraw.drawPolygon(vs, 4, color);</span>
          }
        }
      }
    }

<span class="nc bnc" id="L717" title="All 2 branches missed.">    if ((flags &amp; DebugDraw.e_centerOfMassBit) == DebugDraw.e_centerOfMassBit) {</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">      for (Body b = m_bodyList; b != null; b = b.getNext()) {</span>
<span class="nc" id="L719">        xf.set(b.getTransform());</span>
<span class="nc" id="L720">        xf.p.set(b.getWorldCenter());</span>
<span class="nc" id="L721">        m_debugDraw.drawTransform(xf);</span>
      }
    }

<span class="nc bnc" id="L725" title="All 2 branches missed.">    if ((flags &amp; DebugDraw.e_dynamicTreeBit) == DebugDraw.e_dynamicTreeBit) {</span>
<span class="nc" id="L726">      m_contactManager.m_broadPhase.drawTree(m_debugDraw);</span>
    }
<span class="nc" id="L728">  }</span>

<span class="nc" id="L730">  private final WorldQueryWrapper wqwrapper = new WorldQueryWrapper();</span>

  /**
   * Query the world for all fixtures that potentially overlap the provided AABB.
   * 
   * @param callback a user implemented callback class.
   * @param aabb the query box.
   */
  public void queryAABB(QueryCallback callback, AABB aabb) {
<span class="nc" id="L739">    wqwrapper.broadPhase = m_contactManager.m_broadPhase;</span>
<span class="nc" id="L740">    wqwrapper.callback = callback;</span>
<span class="nc" id="L741">    m_contactManager.m_broadPhase.query(wqwrapper, aabb);</span>
<span class="nc" id="L742">  }</span>

<span class="nc" id="L744">  private final WorldRayCastWrapper wrcwrapper = new WorldRayCastWrapper();</span>
<span class="nc" id="L745">  private final RayCastInput input = new RayCastInput();</span>

  /**
   * Ray-cast the world for all fixtures in the path of the ray. Your callback controls whether you
   * get the closest point, any point, or n-points. The ray-cast ignores shapes that contain the
   * starting point.
   * 
   * @param callback a user implemented callback class.
   * @param point1 the ray starting point
   * @param point2 the ray ending point
   */
  public void raycast(RayCastCallback callback, Vec2 point1, Vec2 point2) {
<span class="nc" id="L757">    wrcwrapper.broadPhase = m_contactManager.m_broadPhase;</span>
<span class="nc" id="L758">    wrcwrapper.callback = callback;</span>
<span class="nc" id="L759">    input.maxFraction = 1.0f;</span>
<span class="nc" id="L760">    input.p1.set(point1);</span>
<span class="nc" id="L761">    input.p2.set(point2);</span>
<span class="nc" id="L762">    m_contactManager.m_broadPhase.raycast(wrcwrapper, input);</span>
<span class="nc" id="L763">  }</span>

  /**
   * Get the world body list. With the returned body, use Body.getNext to get the next body in the
   * world list. A null body indicates the end of the list.
   * 
   * @return the head of the world body list.
   */
  public Body getBodyList() {
<span class="nc" id="L772">    return m_bodyList;</span>
  }

  /**
   * Get the world joint list. With the returned joint, use Joint.getNext to get the next joint in
   * the world list. A null joint indicates the end of the list.
   * 
   * @return the head of the world joint list.
   */
  public Joint getJointList() {
<span class="nc" id="L782">    return m_jointList;</span>
  }

  /**
   * Get the world contact list. With the returned contact, use Contact.getNext to get the next
   * contact in the world list. A null contact indicates the end of the list.
   * 
   * @return the head of the world contact list.
   * @warning contacts are created and destroyed in the middle of a time step. Use ContactListener
   *          to avoid missing contacts.
   */
  public Contact getContactList() {
<span class="nc" id="L794">    return m_contactManager.m_contactList;</span>
  }

  public boolean isSleepingAllowed() {
<span class="nc" id="L798">    return m_allowSleep;</span>
  }

  public void setSleepingAllowed(boolean sleepingAllowed) {
<span class="nc" id="L802">    m_allowSleep = sleepingAllowed;</span>
<span class="nc" id="L803">  }</span>

  /**
   * Enable/disable warm starting. For testing.
   * 
   * @param flag
   */
  public void setWarmStarting(boolean flag) {
<span class="nc" id="L811">    m_warmStarting = flag;</span>
<span class="nc" id="L812">  }</span>

  public boolean isWarmStarting() {
<span class="nc" id="L815">    return m_warmStarting;</span>
  }

  /**
   * Enable/disable continuous physics. For testing.
   * 
   * @param flag
   */
  public void setContinuousPhysics(boolean flag) {
<span class="nc" id="L824">    m_continuousPhysics = flag;</span>
<span class="nc" id="L825">  }</span>

  public boolean isContinuousPhysics() {
<span class="nc" id="L828">    return m_continuousPhysics;</span>
  }



  /**
   * Get the number of broad-phase proxies.
   * 
   * @return
   */
  public int getProxyCount() {
<span class="nc" id="L839">    return m_contactManager.m_broadPhase.getProxyCount();</span>
  }

  /**
   * Get the number of bodies.
   * 
   * @return
   */
  public int getBodyCount() {
<span class="nc" id="L848">    return m_bodyCount;</span>
  }

  /**
   * Get the number of joints.
   * 
   * @return
   */
  public int getJointCount() {
<span class="nc" id="L857">    return m_jointCount;</span>
  }

  /**
   * Get the number of contacts (each may have 0 or more contact points).
   * 
   * @return
   */
  public int getContactCount() {
<span class="nc" id="L866">    return m_contactManager.m_contactCount;</span>
  }

  /**
   * Gets the height of the dynamic tree
   * 
   * @return
   */
  public int getTreeHeight() {
<span class="nc" id="L875">    return m_contactManager.m_broadPhase.getTreeHeight();</span>
  }

  /**
   * Gets the balance of the dynamic tree
   * 
   * @return
   */
  public int getTreeBalance() {
<span class="nc" id="L884">    return m_contactManager.m_broadPhase.getTreeBalance();</span>
  }

  /**
   * Gets the quality of the dynamic tree
   * 
   * @return
   */
  public float getTreeQuality() {
<span class="nc" id="L893">    return m_contactManager.m_broadPhase.getTreeQuality();</span>
  }

  /**
   * Change the global gravity vector.
   * 
   * @param gravity
   */
  public void setGravity(Vec2 gravity) {
<span class="nc" id="L902">    m_gravity.set(gravity);</span>
<span class="nc" id="L903">  }</span>

  /**
   * Get the global gravity vector.
   * 
   * @return
   */
  public Vec2 getGravity() {
<span class="nc" id="L911">    return m_gravity;</span>
  }

  /**
   * Is the world locked (in the middle of a time step).
   * 
   * @return
   */
  public boolean isLocked() {
<span class="nc bnc" id="L920" title="All 2 branches missed.">    return (m_flags &amp; LOCKED) == LOCKED;</span>
  }

  /**
   * Set flag to control automatic clearing of forces after each time step.
   * 
   * @param flag
   */
  public void setAutoClearForces(boolean flag) {
<span class="nc bnc" id="L929" title="All 2 branches missed.">    if (flag) {</span>
<span class="nc" id="L930">      m_flags |= CLEAR_FORCES;</span>
    } else {
<span class="nc" id="L932">      m_flags &amp;= ~CLEAR_FORCES;</span>
    }
<span class="nc" id="L934">  }</span>

  /**
   * Get the flag that controls automatic clearing of forces after each time step.
   * 
   * @return
   */
  public boolean getAutoClearForces() {
<span class="nc bnc" id="L942" title="All 2 branches missed.">    return (m_flags &amp; CLEAR_FORCES) == CLEAR_FORCES;</span>
  }

  /**
   * Get the contact manager for testing purposes
   * 
   * @return
   */
  public ContactManager getContactManager() {
<span class="nc" id="L951">    return m_contactManager;</span>
  }

  public Profile getProfile() {
<span class="nc" id="L955">    return m_profile;</span>
  }

<span class="nc" id="L958">  private final Island island = new Island();</span>
<span class="nc" id="L959">  private Body[] stack = new Body[10]; // TODO djm find a good initial stack number;</span>
<span class="nc" id="L960">  private final Profile islandProfile = new Profile();</span>
<span class="nc" id="L961">  private final Timer broadphaseTimer = new Timer();</span>

  private void solve(TimeStep step) {
<span class="nc" id="L964">    m_profile.solveInit = 0;</span>
<span class="nc" id="L965">    m_profile.solveVelocity = 0;</span>
<span class="nc" id="L966">    m_profile.solvePosition = 0;</span>

    // Size the island for the worst case.
<span class="nc" id="L969">    island.init(m_bodyCount, m_contactManager.m_contactCount, m_jointCount,</span>
        m_contactManager.m_contactListener);

    // Clear all the island flags.
<span class="nc bnc" id="L973" title="All 2 branches missed.">    for (Body b = m_bodyList; b != null; b = b.m_next) {</span>
<span class="nc" id="L974">      b.m_flags &amp;= ~Body.e_islandFlag;</span>
    }
<span class="nc bnc" id="L976" title="All 2 branches missed.">    for (Contact c = m_contactManager.m_contactList; c != null; c = c.m_next) {</span>
<span class="nc" id="L977">      c.m_flags &amp;= ~Contact.ISLAND_FLAG;</span>
    }
<span class="nc bnc" id="L979" title="All 2 branches missed.">    for (Joint j = m_jointList; j != null; j = j.m_next) {</span>
<span class="nc" id="L980">      j.m_islandFlag = false;</span>
    }

    // Build and simulate all awake islands.
<span class="nc" id="L984">    int stackSize = m_bodyCount;</span>
<span class="nc bnc" id="L985" title="All 2 branches missed.">    if (stack.length &lt; stackSize) {</span>
<span class="nc" id="L986">      stack = new Body[stackSize];</span>
    }
<span class="nc bnc" id="L988" title="All 2 branches missed.">    for (Body seed = m_bodyList; seed != null; seed = seed.m_next) {</span>
<span class="nc bnc" id="L989" title="All 2 branches missed.">      if ((seed.m_flags &amp; Body.e_islandFlag) == Body.e_islandFlag) {</span>
<span class="nc" id="L990">        continue;</span>
      }

<span class="nc bnc" id="L993" title="All 4 branches missed.">      if (seed.isAwake() == false || seed.isActive() == false) {</span>
<span class="nc" id="L994">        continue;</span>
      }

      // The seed can be dynamic or kinematic.
<span class="nc bnc" id="L998" title="All 2 branches missed.">      if (seed.getType() == BodyType.STATIC) {</span>
<span class="nc" id="L999">        continue;</span>
      }

      // Reset island and stack.
<span class="nc" id="L1003">      island.clear();</span>
<span class="nc" id="L1004">      int stackCount = 0;</span>
<span class="nc" id="L1005">      stack[stackCount++] = seed;</span>
<span class="nc" id="L1006">      seed.m_flags |= Body.e_islandFlag;</span>

      // Perform a depth first search (DFS) on the constraint graph.
<span class="nc bnc" id="L1009" title="All 2 branches missed.">      while (stackCount &gt; 0) {</span>
        // Grab the next body off the stack and add it to the island.
<span class="nc" id="L1011">        Body b = stack[--stackCount];</span>
<span class="nc bnc" id="L1012" title="All 4 branches missed.">        assert (b.isActive() == true);</span>
<span class="nc" id="L1013">        island.add(b);</span>

        // Make sure the body is awake.
<span class="nc" id="L1016">        b.setAwake(true);</span>

        // To keep islands as small as possible, we don't
        // propagate islands across static bodies.
<span class="nc bnc" id="L1020" title="All 2 branches missed.">        if (b.getType() == BodyType.STATIC) {</span>
<span class="nc" id="L1021">          continue;</span>
        }

        // Search all contacts connected to this body.
<span class="nc bnc" id="L1025" title="All 2 branches missed.">        for (ContactEdge ce = b.m_contactList; ce != null; ce = ce.next) {</span>
<span class="nc" id="L1026">          Contact contact = ce.contact;</span>

          // Has this contact already been added to an island?
<span class="nc bnc" id="L1029" title="All 2 branches missed.">          if ((contact.m_flags &amp; Contact.ISLAND_FLAG) == Contact.ISLAND_FLAG) {</span>
<span class="nc" id="L1030">            continue;</span>
          }

          // Is this contact solid and touching?
<span class="nc bnc" id="L1034" title="All 4 branches missed.">          if (contact.isEnabled() == false || contact.isTouching() == false) {</span>
<span class="nc" id="L1035">            continue;</span>
          }

          // Skip sensors.
<span class="nc" id="L1039">          boolean sensorA = contact.m_fixtureA.m_isSensor;</span>
<span class="nc" id="L1040">          boolean sensorB = contact.m_fixtureB.m_isSensor;</span>
<span class="nc bnc" id="L1041" title="All 4 branches missed.">          if (sensorA || sensorB) {</span>
<span class="nc" id="L1042">            continue;</span>
          }

<span class="nc" id="L1045">          island.add(contact);</span>
<span class="nc" id="L1046">          contact.m_flags |= Contact.ISLAND_FLAG;</span>

<span class="nc" id="L1048">          Body other = ce.other;</span>

          // Was the other body already added to this island?
<span class="nc bnc" id="L1051" title="All 2 branches missed.">          if ((other.m_flags &amp; Body.e_islandFlag) == Body.e_islandFlag) {</span>
<span class="nc" id="L1052">            continue;</span>
          }

<span class="nc bnc" id="L1055" title="All 4 branches missed.">          assert (stackCount &lt; stackSize);</span>
<span class="nc" id="L1056">          stack[stackCount++] = other;</span>
<span class="nc" id="L1057">          other.m_flags |= Body.e_islandFlag;</span>
        }

        // Search all joints connect to this body.
<span class="nc bnc" id="L1061" title="All 2 branches missed.">        for (JointEdge je = b.m_jointList; je != null; je = je.next) {</span>
<span class="nc bnc" id="L1062" title="All 2 branches missed.">          if (je.joint.m_islandFlag == true) {</span>
<span class="nc" id="L1063">            continue;</span>
          }

<span class="nc" id="L1066">          Body other = je.other;</span>

          // Don't simulate joints connected to inactive bodies.
<span class="nc bnc" id="L1069" title="All 2 branches missed.">          if (other.isActive() == false) {</span>
<span class="nc" id="L1070">            continue;</span>
          }

<span class="nc" id="L1073">          island.add(je.joint);</span>
<span class="nc" id="L1074">          je.joint.m_islandFlag = true;</span>

<span class="nc bnc" id="L1076" title="All 2 branches missed.">          if ((other.m_flags &amp; Body.e_islandFlag) == Body.e_islandFlag) {</span>
<span class="nc" id="L1077">            continue;</span>
          }

<span class="nc bnc" id="L1080" title="All 4 branches missed.">          assert (stackCount &lt; stackSize);</span>
<span class="nc" id="L1081">          stack[stackCount++] = other;</span>
<span class="nc" id="L1082">          other.m_flags |= Body.e_islandFlag;</span>
        }
<span class="nc" id="L1084">      }</span>
<span class="nc" id="L1085">      island.solve(islandProfile, step, m_gravity, m_allowSleep);</span>
<span class="nc" id="L1086">      m_profile.solveInit += islandProfile.solveInit;</span>
<span class="nc" id="L1087">      m_profile.solveVelocity += islandProfile.solveVelocity;</span>
<span class="nc" id="L1088">      m_profile.solvePosition += islandProfile.solvePosition;</span>

      // Post solve cleanup.
<span class="nc bnc" id="L1091" title="All 2 branches missed.">      for (int i = 0; i &lt; island.m_bodyCount; ++i) {</span>
        // Allow static bodies to participate in other islands.
<span class="nc" id="L1093">        Body b = island.m_bodies[i];</span>
<span class="nc bnc" id="L1094" title="All 2 branches missed.">        if (b.getType() == BodyType.STATIC) {</span>
<span class="nc" id="L1095">          b.m_flags &amp;= ~Body.e_islandFlag;</span>
        }
      }
    }

<span class="nc" id="L1100">    broadphaseTimer.reset();</span>
    // Synchronize fixtures, check for out of range bodies.
<span class="nc bnc" id="L1102" title="All 2 branches missed.">    for (Body b = m_bodyList; b != null; b = b.getNext()) {</span>
      // If a body was not in an island then it did not move.
<span class="nc bnc" id="L1104" title="All 2 branches missed.">      if ((b.m_flags &amp; Body.e_islandFlag) == 0) {</span>
<span class="nc" id="L1105">        continue;</span>
      }

<span class="nc bnc" id="L1108" title="All 2 branches missed.">      if (b.getType() == BodyType.STATIC) {</span>
<span class="nc" id="L1109">        continue;</span>
      }

      // Update fixtures (for broad-phase).
<span class="nc" id="L1113">      b.synchronizeFixtures();</span>
    }

    // Look for new contacts.
<span class="nc" id="L1117">    m_contactManager.findNewContacts();</span>
<span class="nc" id="L1118">    m_profile.broadphase = broadphaseTimer.getMilliseconds();</span>
<span class="nc" id="L1119">  }</span>

<span class="nc" id="L1121">  private final Island toiIsland = new Island();</span>
<span class="nc" id="L1122">  private final TOIInput toiInput = new TOIInput();</span>
<span class="nc" id="L1123">  private final TOIOutput toiOutput = new TOIOutput();</span>
<span class="nc" id="L1124">  private final TimeStep subStep = new TimeStep();</span>
<span class="nc" id="L1125">  private final Body[] tempBodies = new Body[2];</span>
<span class="nc" id="L1126">  private final Sweep backup1 = new Sweep();</span>
<span class="nc" id="L1127">  private final Sweep backup2 = new Sweep();</span>

  private void solveTOI(final TimeStep step) {

<span class="nc" id="L1131">    final Island island = toiIsland;</span>
<span class="nc" id="L1132">    island.init(2 * Settings.maxTOIContacts, Settings.maxTOIContacts, 0,</span>
        m_contactManager.m_contactListener);
<span class="nc bnc" id="L1134" title="All 2 branches missed.">    if (m_stepComplete) {</span>
<span class="nc bnc" id="L1135" title="All 2 branches missed.">      for (Body b = m_bodyList; b != null; b = b.m_next) {</span>
<span class="nc" id="L1136">        b.m_flags &amp;= ~Body.e_islandFlag;</span>
<span class="nc" id="L1137">        b.m_sweep.alpha0 = 0.0f;</span>
      }

<span class="nc bnc" id="L1140" title="All 2 branches missed.">      for (Contact c = m_contactManager.m_contactList; c != null; c = c.m_next) {</span>
        // Invalidate TOI
<span class="nc" id="L1142">        c.m_flags &amp;= ~(Contact.TOI_FLAG | Contact.ISLAND_FLAG);</span>
<span class="nc" id="L1143">        c.m_toiCount = 0;</span>
<span class="nc" id="L1144">        c.m_toi = 1.0f;</span>
      }
    }

    // Find TOI events and solve them.
    for (;;) {
      // Find the first TOI.
<span class="nc" id="L1151">      Contact minContact = null;</span>
<span class="nc" id="L1152">      float minAlpha = 1.0f;</span>

<span class="nc bnc" id="L1154" title="All 2 branches missed.">      for (Contact c = m_contactManager.m_contactList; c != null; c = c.m_next) {</span>
        // Is this contact disabled?
<span class="nc bnc" id="L1156" title="All 2 branches missed.">        if (c.isEnabled() == false) {</span>
<span class="nc" id="L1157">          continue;</span>
        }

        // Prevent excessive sub-stepping.
<span class="nc bnc" id="L1161" title="All 2 branches missed.">        if (c.m_toiCount &gt; Settings.maxSubSteps) {</span>
<span class="nc" id="L1162">          continue;</span>
        }

<span class="nc" id="L1165">        float alpha = 1.0f;</span>
<span class="nc bnc" id="L1166" title="All 2 branches missed.">        if ((c.m_flags &amp; Contact.TOI_FLAG) != 0) {</span>
          // This contact has a valid cached TOI.
<span class="nc" id="L1168">          alpha = c.m_toi;</span>
        } else {
<span class="nc" id="L1170">          Fixture fA = c.getFixtureA();</span>
<span class="nc" id="L1171">          Fixture fB = c.getFixtureB();</span>

          // Is there a sensor?
<span class="nc bnc" id="L1174" title="All 4 branches missed.">          if (fA.isSensor() || fB.isSensor()) {</span>
<span class="nc" id="L1175">            continue;</span>
          }

<span class="nc" id="L1178">          Body bA = fA.getBody();</span>
<span class="nc" id="L1179">          Body bB = fB.getBody();</span>

<span class="nc" id="L1181">          BodyType typeA = bA.m_type;</span>
<span class="nc" id="L1182">          BodyType typeB = bB.m_type;</span>
<span class="nc bnc" id="L1183" title="All 6 branches missed.">          assert (typeA == BodyType.DYNAMIC || typeB == BodyType.DYNAMIC);</span>

<span class="nc bnc" id="L1185" title="All 4 branches missed.">          boolean activeA = bA.isAwake() &amp;&amp; typeA != BodyType.STATIC;</span>
<span class="nc bnc" id="L1186" title="All 4 branches missed.">          boolean activeB = bB.isAwake() &amp;&amp; typeB != BodyType.STATIC;</span>

          // Is at least one body active (awake and dynamic or kinematic)?
<span class="nc bnc" id="L1189" title="All 4 branches missed.">          if (activeA == false &amp;&amp; activeB == false) {</span>
<span class="nc" id="L1190">            continue;</span>
          }

<span class="nc bnc" id="L1193" title="All 4 branches missed.">          boolean collideA = bA.isBullet() || typeA != BodyType.DYNAMIC;</span>
<span class="nc bnc" id="L1194" title="All 4 branches missed.">          boolean collideB = bB.isBullet() || typeB != BodyType.DYNAMIC;</span>

          // Are these two non-bullet dynamic bodies?
<span class="nc bnc" id="L1197" title="All 4 branches missed.">          if (collideA == false &amp;&amp; collideB == false) {</span>
<span class="nc" id="L1198">            continue;</span>
          }

          // Compute the TOI for this contact.
          // Put the sweeps onto the same time interval.
<span class="nc" id="L1203">          float alpha0 = bA.m_sweep.alpha0;</span>

<span class="nc bnc" id="L1205" title="All 2 branches missed.">          if (bA.m_sweep.alpha0 &lt; bB.m_sweep.alpha0) {</span>
<span class="nc" id="L1206">            alpha0 = bB.m_sweep.alpha0;</span>
<span class="nc" id="L1207">            bA.m_sweep.advance(alpha0);</span>
<span class="nc bnc" id="L1208" title="All 2 branches missed.">          } else if (bB.m_sweep.alpha0 &lt; bA.m_sweep.alpha0) {</span>
<span class="nc" id="L1209">            alpha0 = bA.m_sweep.alpha0;</span>
<span class="nc" id="L1210">            bB.m_sweep.advance(alpha0);</span>
          }

<span class="nc bnc" id="L1213" title="All 4 branches missed.">          assert (alpha0 &lt; 1.0f);</span>

<span class="nc" id="L1215">          int indexA = c.getChildIndexA();</span>
<span class="nc" id="L1216">          int indexB = c.getChildIndexB();</span>

          // Compute the time of impact in interval [0, minTOI]
<span class="nc" id="L1219">          final TOIInput input = toiInput;</span>
<span class="nc" id="L1220">          input.proxyA.set(fA.getShape(), indexA);</span>
<span class="nc" id="L1221">          input.proxyB.set(fB.getShape(), indexB);</span>
<span class="nc" id="L1222">          input.sweepA.set(bA.m_sweep);</span>
<span class="nc" id="L1223">          input.sweepB.set(bB.m_sweep);</span>
<span class="nc" id="L1224">          input.tMax = 1.0f;</span>

<span class="nc" id="L1226">          pool.getTimeOfImpact().timeOfImpact(toiOutput, input);</span>

          // Beta is the fraction of the remaining portion of the .
<span class="nc" id="L1229">          float beta = toiOutput.t;</span>
<span class="nc bnc" id="L1230" title="All 2 branches missed.">          if (toiOutput.state == TOIOutputState.TOUCHING) {</span>
<span class="nc" id="L1231">            alpha = MathUtils.min(alpha0 + (1.0f - alpha0) * beta, 1.0f);</span>
          } else {
<span class="nc" id="L1233">            alpha = 1.0f;</span>
          }

<span class="nc" id="L1236">          c.m_toi = alpha;</span>
<span class="nc" id="L1237">          c.m_flags |= Contact.TOI_FLAG;</span>
        }

<span class="nc bnc" id="L1240" title="All 2 branches missed.">        if (alpha &lt; minAlpha) {</span>
          // This is the minimum TOI found so far.
<span class="nc" id="L1242">          minContact = c;</span>
<span class="nc" id="L1243">          minAlpha = alpha;</span>
        }
      }

<span class="nc bnc" id="L1247" title="All 4 branches missed.">      if (minContact == null || 1.0f - 10.0f * Settings.EPSILON &lt; minAlpha) {</span>
        // No more TOI events. Done!
<span class="nc" id="L1249">        m_stepComplete = true;</span>
<span class="nc" id="L1250">        break;</span>
      }

      // Advance the bodies to the TOI.
<span class="nc" id="L1254">      Fixture fA = minContact.getFixtureA();</span>
<span class="nc" id="L1255">      Fixture fB = minContact.getFixtureB();</span>
<span class="nc" id="L1256">      Body bA = fA.getBody();</span>
<span class="nc" id="L1257">      Body bB = fB.getBody();</span>

<span class="nc" id="L1259">      backup1.set(bA.m_sweep);</span>
<span class="nc" id="L1260">      backup2.set(bB.m_sweep);</span>

<span class="nc" id="L1262">      bA.advance(minAlpha);</span>
<span class="nc" id="L1263">      bB.advance(minAlpha);</span>

      // The TOI contact likely has some new contact points.
<span class="nc" id="L1266">      minContact.update(m_contactManager.m_contactListener);</span>
<span class="nc" id="L1267">      minContact.m_flags &amp;= ~Contact.TOI_FLAG;</span>
<span class="nc" id="L1268">      ++minContact.m_toiCount;</span>

      // Is the contact solid?
<span class="nc bnc" id="L1271" title="All 4 branches missed.">      if (minContact.isEnabled() == false || minContact.isTouching() == false) {</span>
        // Restore the sweeps.
<span class="nc" id="L1273">        minContact.setEnabled(false);</span>
<span class="nc" id="L1274">        bA.m_sweep.set(backup1);</span>
<span class="nc" id="L1275">        bB.m_sweep.set(backup2);</span>
<span class="nc" id="L1276">        bA.synchronizeTransform();</span>
<span class="nc" id="L1277">        bB.synchronizeTransform();</span>
<span class="nc" id="L1278">        continue;</span>
      }

<span class="nc" id="L1281">      bA.setAwake(true);</span>
<span class="nc" id="L1282">      bB.setAwake(true);</span>

      // Build the island
<span class="nc" id="L1285">      island.clear();</span>
<span class="nc" id="L1286">      island.add(bA);</span>
<span class="nc" id="L1287">      island.add(bB);</span>
<span class="nc" id="L1288">      island.add(minContact);</span>

<span class="nc" id="L1290">      bA.m_flags |= Body.e_islandFlag;</span>
<span class="nc" id="L1291">      bB.m_flags |= Body.e_islandFlag;</span>
<span class="nc" id="L1292">      minContact.m_flags |= Contact.ISLAND_FLAG;</span>

      // Get contacts on bodyA and bodyB.
<span class="nc" id="L1295">      tempBodies[0] = bA;</span>
<span class="nc" id="L1296">      tempBodies[1] = bB;</span>
<span class="nc bnc" id="L1297" title="All 2 branches missed.">      for (int i = 0; i &lt; 2; ++i) {</span>
<span class="nc" id="L1298">        Body body = tempBodies[i];</span>
<span class="nc bnc" id="L1299" title="All 2 branches missed.">        if (body.m_type == BodyType.DYNAMIC) {</span>
<span class="nc bnc" id="L1300" title="All 2 branches missed.">          for (ContactEdge ce = body.m_contactList; ce != null; ce = ce.next) {</span>
<span class="nc bnc" id="L1301" title="All 2 branches missed.">            if (island.m_bodyCount == island.m_bodyCapacity) {</span>
<span class="nc" id="L1302">              break;</span>
            }

<span class="nc bnc" id="L1305" title="All 2 branches missed.">            if (island.m_contactCount == island.m_contactCapacity) {</span>
<span class="nc" id="L1306">              break;</span>
            }

<span class="nc" id="L1309">            Contact contact = ce.contact;</span>

            // Has this contact already been added to the island?
<span class="nc bnc" id="L1312" title="All 2 branches missed.">            if ((contact.m_flags &amp; Contact.ISLAND_FLAG) != 0) {</span>
<span class="nc" id="L1313">              continue;</span>
            }

            // Only add static, kinematic, or bullet bodies.
<span class="nc" id="L1317">            Body other = ce.other;</span>
<span class="nc bnc" id="L1318" title="All 4 branches missed.">            if (other.m_type == BodyType.DYNAMIC &amp;&amp; body.isBullet() == false</span>
<span class="nc bnc" id="L1319" title="All 2 branches missed.">                &amp;&amp; other.isBullet() == false) {</span>
<span class="nc" id="L1320">              continue;</span>
            }

            // Skip sensors.
<span class="nc" id="L1324">            boolean sensorA = contact.m_fixtureA.m_isSensor;</span>
<span class="nc" id="L1325">            boolean sensorB = contact.m_fixtureB.m_isSensor;</span>
<span class="nc bnc" id="L1326" title="All 4 branches missed.">            if (sensorA || sensorB) {</span>
<span class="nc" id="L1327">              continue;</span>
            }

            // Tentatively advance the body to the TOI.
<span class="nc" id="L1331">            backup1.set(other.m_sweep);</span>
<span class="nc bnc" id="L1332" title="All 2 branches missed.">            if ((other.m_flags &amp; Body.e_islandFlag) == 0) {</span>
<span class="nc" id="L1333">              other.advance(minAlpha);</span>
            }

            // Update the contact points
<span class="nc" id="L1337">            contact.update(m_contactManager.m_contactListener);</span>

            // Was the contact disabled by the user?
<span class="nc bnc" id="L1340" title="All 2 branches missed.">            if (contact.isEnabled() == false) {</span>
<span class="nc" id="L1341">              other.m_sweep.set(backup1);</span>
<span class="nc" id="L1342">              other.synchronizeTransform();</span>
<span class="nc" id="L1343">              continue;</span>
            }

            // Are there contact points?
<span class="nc bnc" id="L1347" title="All 2 branches missed.">            if (contact.isTouching() == false) {</span>
<span class="nc" id="L1348">              other.m_sweep.set(backup1);</span>
<span class="nc" id="L1349">              other.synchronizeTransform();</span>
<span class="nc" id="L1350">              continue;</span>
            }

            // Add the contact to the island
<span class="nc" id="L1354">            contact.m_flags |= Contact.ISLAND_FLAG;</span>
<span class="nc" id="L1355">            island.add(contact);</span>

            // Has the other body already been added to the island?
<span class="nc bnc" id="L1358" title="All 2 branches missed.">            if ((other.m_flags &amp; Body.e_islandFlag) != 0) {</span>
<span class="nc" id="L1359">              continue;</span>
            }

            // Add the other body to the island.
<span class="nc" id="L1363">            other.m_flags |= Body.e_islandFlag;</span>

<span class="nc bnc" id="L1365" title="All 2 branches missed.">            if (other.m_type != BodyType.STATIC) {</span>
<span class="nc" id="L1366">              other.setAwake(true);</span>
            }

<span class="nc" id="L1369">            island.add(other);</span>
          }
        }
      }

<span class="nc" id="L1374">      subStep.dt = (1.0f - minAlpha) * step.dt;</span>
<span class="nc" id="L1375">      subStep.inv_dt = 1.0f / subStep.dt;</span>
<span class="nc" id="L1376">      subStep.dtRatio = 1.0f;</span>
<span class="nc" id="L1377">      subStep.positionIterations = 20;</span>
<span class="nc" id="L1378">      subStep.velocityIterations = step.velocityIterations;</span>
<span class="nc" id="L1379">      subStep.warmStarting = false;</span>
<span class="nc" id="L1380">      island.solveTOI(subStep, bA.m_islandIndex, bB.m_islandIndex);</span>

      // Reset island flags and synchronize broad-phase proxies.
<span class="nc bnc" id="L1383" title="All 2 branches missed.">      for (int i = 0; i &lt; island.m_bodyCount; ++i) {</span>
<span class="nc" id="L1384">        Body body = island.m_bodies[i];</span>
<span class="nc" id="L1385">        body.m_flags &amp;= ~Body.e_islandFlag;</span>

<span class="nc bnc" id="L1387" title="All 2 branches missed.">        if (body.m_type != BodyType.DYNAMIC) {</span>
<span class="nc" id="L1388">          continue;</span>
        }

<span class="nc" id="L1391">        body.synchronizeFixtures();</span>

        // Invalidate all contact TOIs on this displaced body.
<span class="nc bnc" id="L1394" title="All 2 branches missed.">        for (ContactEdge ce = body.m_contactList; ce != null; ce = ce.next) {</span>
<span class="nc" id="L1395">          ce.contact.m_flags &amp;= ~(Contact.TOI_FLAG | Contact.ISLAND_FLAG);</span>
        }
      }

      // Commit fixture proxy movements to the broad-phase so that new contacts are created.
      // Also, some contacts can be destroyed.
<span class="nc" id="L1401">      m_contactManager.findNewContacts();</span>

<span class="nc bnc" id="L1403" title="All 2 branches missed.">      if (m_subStepping) {</span>
<span class="nc" id="L1404">        m_stepComplete = false;</span>
<span class="nc" id="L1405">        break;</span>
      }
<span class="nc" id="L1407">    }</span>
<span class="nc" id="L1408">  }</span>

  private void drawJoint(Joint joint) {
<span class="nc" id="L1411">    Body bodyA = joint.getBodyA();</span>
<span class="nc" id="L1412">    Body bodyB = joint.getBodyB();</span>
<span class="nc" id="L1413">    Transform xf1 = bodyA.getTransform();</span>
<span class="nc" id="L1414">    Transform xf2 = bodyB.getTransform();</span>
<span class="nc" id="L1415">    Vec2 x1 = xf1.p;</span>
<span class="nc" id="L1416">    Vec2 x2 = xf2.p;</span>
<span class="nc" id="L1417">    Vec2 p1 = pool.popVec2();</span>
<span class="nc" id="L1418">    Vec2 p2 = pool.popVec2();</span>
<span class="nc" id="L1419">    joint.getAnchorA(p1);</span>
<span class="nc" id="L1420">    joint.getAnchorB(p2);</span>

<span class="nc" id="L1422">    color.set(0.5f, 0.8f, 0.8f);</span>

<span class="nc bnc" id="L1424" title="All 4 branches missed.">    switch (joint.getType()) {</span>
    // TODO djm write after writing joints
      case DISTANCE:
<span class="nc" id="L1427">        m_debugDraw.drawSegment(p1, p2, color);</span>
<span class="nc" id="L1428">        break;</span>

      case PULLEY: {
<span class="nc" id="L1431">        PulleyJoint pulley = (PulleyJoint) joint;</span>
<span class="nc" id="L1432">        Vec2 s1 = pulley.getGroundAnchorA();</span>
<span class="nc" id="L1433">        Vec2 s2 = pulley.getGroundAnchorB();</span>
<span class="nc" id="L1434">        m_debugDraw.drawSegment(s1, p1, color);</span>
<span class="nc" id="L1435">        m_debugDraw.drawSegment(s2, p2, color);</span>
<span class="nc" id="L1436">        m_debugDraw.drawSegment(s1, s2, color);</span>
      }
<span class="nc" id="L1438">        break;</span>
      case CONSTANT_VOLUME:
      case MOUSE:
        // don't draw this
<span class="nc" id="L1442">        break;</span>
      default:
<span class="nc" id="L1444">        m_debugDraw.drawSegment(x1, p1, color);</span>
<span class="nc" id="L1445">        m_debugDraw.drawSegment(p1, p2, color);</span>
<span class="nc" id="L1446">        m_debugDraw.drawSegment(x2, p2, color);</span>
    }
<span class="nc" id="L1448">    pool.pushVec2(2);</span>
<span class="nc" id="L1449">  }</span>

  // NOTE this corresponds to the liquid test, so the debugdraw can draw
  // the liquid particles correctly. They should be the same.
<span class="nc" id="L1453">  private static Integer LIQUID_INT = new Integer(1234598372);</span>
<span class="nc" id="L1454">  private float liquidLength = .12f;</span>
<span class="nc" id="L1455">  private float averageLinearVel = -1;</span>
<span class="nc" id="L1456">  private final Vec2 liquidOffset = new Vec2();</span>
<span class="nc" id="L1457">  private final Vec2 circCenterMoved = new Vec2();</span>
<span class="nc" id="L1458">  private final Color3f liquidColor = new Color3f(.4f, .4f, 1f);</span>

<span class="nc" id="L1460">  private final Vec2 center = new Vec2();</span>
<span class="nc" id="L1461">  private final Vec2 axis = new Vec2();</span>
<span class="nc" id="L1462">  private final Vec2 v1 = new Vec2();</span>
<span class="nc" id="L1463">  private final Vec2 v2 = new Vec2();</span>
<span class="nc" id="L1464">  private final Vec2Array tlvertices = new Vec2Array();</span>

  private void drawShape(Fixture fixture, Transform xf, Color3f color) {
<span class="nc bnc" id="L1467" title="All 5 branches missed.">    switch (fixture.getType()) {</span>
      case CIRCLE: {
<span class="nc" id="L1469">        CircleShape circle = (CircleShape) fixture.getShape();</span>

        // Vec2 center = Mul(xf, circle.m_p);
<span class="nc" id="L1472">        Transform.mulToOutUnsafe(xf, circle.m_p, center);</span>
<span class="nc" id="L1473">        float radius = circle.m_radius;</span>
<span class="nc" id="L1474">        xf.q.getXAxis(axis);</span>

<span class="nc bnc" id="L1476" title="All 4 branches missed.">        if (fixture.getUserData() != null &amp;&amp; fixture.getUserData().equals(LIQUID_INT)) {</span>
<span class="nc" id="L1477">          Body b = fixture.getBody();</span>
<span class="nc" id="L1478">          liquidOffset.set(b.m_linearVelocity);</span>
<span class="nc" id="L1479">          float linVelLength = b.m_linearVelocity.length();</span>
<span class="nc bnc" id="L1480" title="All 2 branches missed.">          if (averageLinearVel == -1) {</span>
<span class="nc" id="L1481">            averageLinearVel = linVelLength;</span>
          } else {
<span class="nc" id="L1483">            averageLinearVel = .98f * averageLinearVel + .02f * linVelLength;</span>
          }
<span class="nc" id="L1485">          liquidOffset.mulLocal(liquidLength / averageLinearVel / 2);</span>
<span class="nc" id="L1486">          circCenterMoved.set(center).addLocal(liquidOffset);</span>
<span class="nc" id="L1487">          center.subLocal(liquidOffset);</span>
<span class="nc" id="L1488">          m_debugDraw.drawSegment(center, circCenterMoved, liquidColor);</span>
<span class="nc" id="L1489">          return;</span>
        }

<span class="nc" id="L1492">        m_debugDraw.drawSolidCircle(center, radius, axis, color);</span>
      }
<span class="nc" id="L1494">        break;</span>

      case POLYGON: {
<span class="nc" id="L1497">        PolygonShape poly = (PolygonShape) fixture.getShape();</span>
<span class="nc" id="L1498">        int vertexCount = poly.m_count;</span>
<span class="nc bnc" id="L1499" title="All 4 branches missed.">        assert (vertexCount &lt;= Settings.maxPolygonVertices);</span>
<span class="nc" id="L1500">        Vec2[] vertices = tlvertices.get(Settings.maxPolygonVertices);</span>

<span class="nc bnc" id="L1502" title="All 2 branches missed.">        for (int i = 0; i &lt; vertexCount; ++i) {</span>
          // vertices[i] = Mul(xf, poly.m_vertices[i]);
<span class="nc" id="L1504">          Transform.mulToOutUnsafe(xf, poly.m_vertices[i], vertices[i]);</span>
        }

<span class="nc" id="L1507">        m_debugDraw.drawSolidPolygon(vertices, vertexCount, color);</span>
      }
<span class="nc" id="L1509">        break;</span>
      case EDGE: {
<span class="nc" id="L1511">        EdgeShape edge = (EdgeShape) fixture.getShape();</span>
<span class="nc" id="L1512">        Transform.mulToOutUnsafe(xf, edge.m_vertex1, v1);</span>
<span class="nc" id="L1513">        Transform.mulToOutUnsafe(xf, edge.m_vertex2, v2);</span>
<span class="nc" id="L1514">        m_debugDraw.drawSegment(v1, v2, color);</span>
      }
<span class="nc" id="L1516">        break;</span>

      case CHAIN: {
<span class="nc" id="L1519">        ChainShape chain = (ChainShape) fixture.getShape();</span>
<span class="nc" id="L1520">        int count = chain.m_count;</span>
<span class="nc" id="L1521">        Vec2[] vertices = chain.m_vertices;</span>

<span class="nc" id="L1523">        Transform.mulToOutUnsafe(xf, vertices[0], v1);</span>
<span class="nc bnc" id="L1524" title="All 2 branches missed.">        for (int i = 1; i &lt; count; ++i) {</span>
<span class="nc" id="L1525">          Transform.mulToOutUnsafe(xf, vertices[i], v2);</span>
<span class="nc" id="L1526">          m_debugDraw.drawSegment(v1, v2, color);</span>
<span class="nc" id="L1527">          m_debugDraw.drawCircle(v1, 0.05f, color);</span>
<span class="nc" id="L1528">          v1.set(v2);</span>
        }
      }
<span class="nc" id="L1531">        break;</span>
      default:
        break;
    }
<span class="nc" id="L1535">  }</span>
}


<span class="nc" id="L1539">class WorldQueryWrapper implements TreeCallback {</span>
  public boolean treeCallback(int nodeId) {
<span class="nc" id="L1541">    FixtureProxy proxy = (FixtureProxy) broadPhase.getUserData(nodeId);</span>
<span class="nc" id="L1542">    return callback.reportFixture(proxy.fixture);</span>
  }

  BroadPhase broadPhase;
  QueryCallback callback;
};


<span class="nc" id="L1550">class WorldRayCastWrapper implements TreeRayCastCallback {</span>

  // djm pooling
<span class="nc" id="L1553">  private final RayCastOutput output = new RayCastOutput();</span>
<span class="nc" id="L1554">  private final Vec2 temp = new Vec2();</span>
<span class="nc" id="L1555">  private final Vec2 point = new Vec2();</span>

  public float raycastCallback(RayCastInput input, int nodeId) {
<span class="nc" id="L1558">    Object userData = broadPhase.getUserData(nodeId);</span>
<span class="nc" id="L1559">    FixtureProxy proxy = (FixtureProxy) userData;</span>
<span class="nc" id="L1560">    Fixture fixture = proxy.fixture;</span>
<span class="nc" id="L1561">    int index = proxy.childIndex;</span>
<span class="nc" id="L1562">    boolean hit = fixture.raycast(output, input, index);</span>

<span class="nc bnc" id="L1564" title="All 2 branches missed.">    if (hit) {</span>
<span class="nc" id="L1565">      float fraction = output.fraction;</span>
      // Vec2 point = (1.0f - fraction) * input.p1 + fraction * input.p2;
<span class="nc" id="L1567">      temp.set(input.p2).mulLocal(fraction);</span>
<span class="nc" id="L1568">      point.set(input.p1).mulLocal(1 - fraction).addLocal(temp);</span>
<span class="nc" id="L1569">      return callback.reportFixture(fixture, point, output.normal, fraction);</span>
    }

<span class="nc" id="L1572">    return input.maxFraction;</span>
  }

  BroadPhase broadPhase;
  RayCastCallback callback;
};
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>