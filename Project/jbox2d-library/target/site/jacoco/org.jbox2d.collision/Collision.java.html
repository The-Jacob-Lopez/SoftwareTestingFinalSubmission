<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Collision.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jbox2d-library</a> &gt; <a href="index.source.html" class="el_package">org.jbox2d.collision</a> &gt; <span class="el_source">Collision.java</span></div><h1>Collision.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2013, Daniel Murphy
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 	* Redistributions of source code must retain the above copyright notice,
 * 	  this list of conditions and the following disclaimer.
 * 	* Redistributions in binary form must reproduce the above copyright notice,
 * 	  this list of conditions and the following disclaimer in the documentation
 * 	  and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************/
package org.jbox2d.collision;

import org.jbox2d.collision.Distance.SimplexCache;
import org.jbox2d.collision.Manifold.ManifoldType;
import org.jbox2d.collision.shapes.CircleShape;
import org.jbox2d.collision.shapes.EdgeShape;
import org.jbox2d.collision.shapes.PolygonShape;
import org.jbox2d.collision.shapes.Shape;
import org.jbox2d.common.MathUtils;
import org.jbox2d.common.Rot;
import org.jbox2d.common.Settings;
import org.jbox2d.common.Transform;
import org.jbox2d.common.Vec2;
import org.jbox2d.pooling.IWorldPool;

/**
 * Functions used for computing contact points, distance queries, and TOI queries. Collision methods
 * are non-static for pooling speed, retrieve a collision object from the {@link SingletonPool}.
 * Should not be finalructed.
 * 
 * @author Daniel Murphy
 */
<span class="pc bpc" id="L46" title="1 of 2 branches missed.">public class Collision {</span>
  public static final int NULL_FEATURE = Integer.MAX_VALUE;

  private final IWorldPool pool;

<span class="fc" id="L51">  public Collision(IWorldPool argPool) {</span>
<span class="fc" id="L52">    incidentEdge[0] = new ClipVertex();</span>
<span class="fc" id="L53">    incidentEdge[1] = new ClipVertex();</span>
<span class="fc" id="L54">    clipPoints1[0] = new ClipVertex();</span>
<span class="fc" id="L55">    clipPoints1[1] = new ClipVertex();</span>
<span class="fc" id="L56">    clipPoints2[0] = new ClipVertex();</span>
<span class="fc" id="L57">    clipPoints2[1] = new ClipVertex();</span>
<span class="fc" id="L58">    pool = argPool;</span>
<span class="fc" id="L59">  }</span>

<span class="fc" id="L61">  private final DistanceInput input = new DistanceInput();</span>
<span class="fc" id="L62">  private final SimplexCache cache = new SimplexCache();</span>
<span class="fc" id="L63">  private final DistanceOutput output = new DistanceOutput();</span>

  /**
   * Determine if two generic shapes overlap.
   * 
   * @param shapeA
   * @param shapeB
   * @param xfA
   * @param xfB
   * @return
   */
  public final boolean testOverlap(Shape shapeA, int indexA, Shape shapeB, int indexB,
      Transform xfA, Transform xfB) {
<span class="fc" id="L76">    input.proxyA.set(shapeA, indexA);</span>
<span class="fc" id="L77">    input.proxyB.set(shapeB, indexB);</span>
<span class="fc" id="L78">    input.transformA.set(xfA);</span>
<span class="fc" id="L79">    input.transformB.set(xfB);</span>
<span class="fc" id="L80">    input.useRadii = true;</span>

<span class="fc" id="L82">    cache.count = 0;</span>

<span class="fc" id="L84">    pool.getDistance().distance(output, cache, input);</span>
    // djm note: anything significant about 10.0f?
<span class="fc bfc" id="L86" title="All 2 branches covered.">    return output.distance &lt; 10.0f * Settings.EPSILON;</span>
  }

  /**
   * Compute the point states given two manifolds. The states pertain to the transition from
   * manifold1 to manifold2. So state1 is either persist or remove while state2 is either add or
   * persist.
   * 
   * @param state1
   * @param state2
   * @param manifold1
   * @param manifold2
   */
  public static final void getPointStates(final PointState[] state1, final PointState[] state2,
      final Manifold manifold1, final Manifold manifold2) {

<span class="fc bfc" id="L102" title="All 2 branches covered.">    for (int i = 0; i &lt; Settings.maxManifoldPoints; i++) {</span>
<span class="fc" id="L103">      state1[i] = PointState.NULL_STATE;</span>
<span class="fc" id="L104">      state2[i] = PointState.NULL_STATE;</span>
    }

    // Detect persists and removes.
<span class="fc bfc" id="L108" title="All 2 branches covered.">    for (int i = 0; i &lt; manifold1.pointCount; i++) {</span>
<span class="fc" id="L109">      ContactID id = manifold1.points[i].id;</span>

<span class="fc" id="L111">      state1[i] = PointState.REMOVE_STATE;</span>

<span class="pc bpc" id="L113" title="1 of 2 branches missed.">      for (int j = 0; j &lt; manifold2.pointCount; j++) {</span>
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">        if (manifold2.points[j].id.isEqual(id)) {</span>
<span class="fc" id="L115">          state1[i] = PointState.PERSIST_STATE;</span>
<span class="fc" id="L116">          break;</span>
        }
      }
    }

    // Detect persists and adds
<span class="fc bfc" id="L122" title="All 2 branches covered.">    for (int i = 0; i &lt; manifold2.pointCount; i++) {</span>
<span class="fc" id="L123">      ContactID id = manifold2.points[i].id;</span>

<span class="fc" id="L125">      state2[i] = PointState.ADD_STATE;</span>

<span class="pc bpc" id="L127" title="1 of 2 branches missed.">      for (int j = 0; j &lt; manifold1.pointCount; j++) {</span>
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">        if (manifold1.points[j].id.isEqual(id)) {</span>
<span class="fc" id="L129">          state2[i] = PointState.PERSIST_STATE;</span>
<span class="fc" id="L130">          break;</span>
        }
      }
    }
<span class="fc" id="L134">  }</span>

  /**
   * Clipping for contact manifolds. Sutherland-Hodgman clipping.
   * 
   * @param vOut
   * @param vIn
   * @param normal
   * @param offset
   * @return
   */
  public static final int clipSegmentToLine(final ClipVertex[] vOut, final ClipVertex[] vIn,
      final Vec2 normal, float offset, int vertexIndexA) {

    // Start with no output points
<span class="fc" id="L149">    int numOut = 0;</span>
<span class="fc" id="L150">    final ClipVertex vIn0 = vIn[0];</span>
<span class="fc" id="L151">    final ClipVertex vIn1 = vIn[1];</span>
<span class="fc" id="L152">    final Vec2 vIn0v = vIn0.v;</span>
<span class="fc" id="L153">    final Vec2 vIn1v = vIn1.v;</span>

    // Calculate the distance of end points to the line
<span class="fc" id="L156">    float distance0 = Vec2.dot(normal, vIn0v) - offset;</span>
<span class="fc" id="L157">    float distance1 = Vec2.dot(normal, vIn1v) - offset;</span>

    // If the points are behind the plane
<span class="fc bfc" id="L160" title="All 2 branches covered.">    if (distance0 &lt;= 0.0f) {</span>
<span class="fc" id="L161">      vOut[numOut++].set(vIn0);</span>
    }
<span class="fc bfc" id="L163" title="All 2 branches covered.">    if (distance1 &lt;= 0.0f) {</span>
<span class="fc" id="L164">      vOut[numOut++].set(vIn1);</span>
    }

    // If the points are on different sides of the plane
<span class="fc bfc" id="L168" title="All 2 branches covered.">    if (distance0 * distance1 &lt; 0.0f) {</span>
      // Find intersection point of edge and plane
<span class="fc" id="L170">      float interp = distance0 / (distance0 - distance1);</span>

<span class="fc" id="L172">      ClipVertex vOutNO = vOut[numOut];</span>
      // vOut[numOut].v = vIn[0].v + interp * (vIn[1].v - vIn[0].v);
<span class="fc" id="L174">      vOutNO.v.x = vIn0v.x + interp * (vIn1v.x - vIn0v.x);</span>
<span class="fc" id="L175">      vOutNO.v.y = vIn0v.y + interp * (vIn1v.y - vIn0v.y);</span>

      // VertexA is hitting edgeB.
<span class="fc" id="L178">      vOutNO.id.indexA = (byte) vertexIndexA;</span>
<span class="fc" id="L179">      vOutNO.id.indexB = vIn0.id.indexB;</span>
<span class="fc" id="L180">      vOutNO.id.typeA = (byte) ContactID.Type.VERTEX.ordinal();</span>
<span class="fc" id="L181">      vOutNO.id.typeB = (byte) ContactID.Type.FACE.ordinal();</span>
<span class="fc" id="L182">      ++numOut;</span>
    }

<span class="fc" id="L185">    return numOut;</span>
  }

  // #### COLLISION STUFF (not from collision.h or collision.cpp) ####

  // djm pooling
<span class="fc" id="L191">  private static Vec2 d = new Vec2();</span>

  /**
   * Compute the collision manifold between two circles.
   * 
   * @param manifold
   * @param circle1
   * @param xfA
   * @param circle2
   * @param xfB
   */
  public final void collideCircles(Manifold manifold, final CircleShape circle1,
      final Transform xfA, final CircleShape circle2, final Transform xfB) {
<span class="fc" id="L204">    manifold.pointCount = 0;</span>
    // before inline:
    // Transform.mulToOut(xfA, circle1.m_p, pA);
    // Transform.mulToOut(xfB, circle2.m_p, pB);
    // d.set(pB).subLocal(pA);
    // float distSqr = d.x * d.x + d.y * d.y;

    // after inline:
<span class="fc" id="L212">    Vec2 circle1p = circle1.m_p;</span>
<span class="fc" id="L213">    Vec2 circle2p = circle2.m_p;</span>
<span class="fc" id="L214">    float pAx = (xfA.q.c * circle1p.x - xfA.q.s * circle1p.y) + xfA.p.x;</span>
<span class="fc" id="L215">    float pAy = (xfA.q.s * circle1p.x + xfA.q.c * circle1p.y) + xfA.p.y;</span>
<span class="fc" id="L216">    float pBx = (xfB.q.c * circle2p.x - xfB.q.s * circle2p.y) + xfB.p.x;</span>
<span class="fc" id="L217">    float pBy = (xfB.q.s * circle2p.x + xfB.q.c * circle2p.y) + xfB.p.y;</span>
<span class="fc" id="L218">    float dx = pBx - pAx;</span>
<span class="fc" id="L219">    float dy = pBy - pAy;</span>
<span class="fc" id="L220">    float distSqr = dx * dx + dy * dy;</span>
    // end inline

<span class="fc" id="L223">    final float radius = circle1.m_radius + circle2.m_radius;</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">    if (distSqr &gt; radius * radius) {</span>
<span class="fc" id="L225">      return;</span>
    }

<span class="fc" id="L228">    manifold.type = ManifoldType.CIRCLES;</span>
<span class="fc" id="L229">    manifold.localPoint.set(circle1p);</span>
<span class="fc" id="L230">    manifold.localNormal.setZero();</span>
<span class="fc" id="L231">    manifold.pointCount = 1;</span>

<span class="fc" id="L233">    manifold.points[0].localPoint.set(circle2p);</span>
<span class="fc" id="L234">    manifold.points[0].id.zero();</span>
<span class="fc" id="L235">  }</span>

  // djm pooling, and from above

  /**
   * Compute the collision manifold between a polygon and a circle.
   * 
   * @param manifold
   * @param polygon
   * @param xfA
   * @param circle
   * @param xfB
   */
  public final void collidePolygonAndCircle(Manifold manifold, final PolygonShape polygon,
      final Transform xfA, final CircleShape circle, final Transform xfB) {
<span class="fc" id="L250">    manifold.pointCount = 0;</span>
    // Vec2 v = circle.m_p;

    // Compute circle position in the frame of the polygon.
    // before inline:
    // Transform.mulToOutUnsafe(xfB, circle.m_p, c);
    // Transform.mulTransToOut(xfA, c, cLocal);
    // final float cLocalx = cLocal.x;
    // final float cLocaly = cLocal.y;
    // after inline:
<span class="fc" id="L260">    final Vec2 circlep = circle.m_p;</span>
<span class="fc" id="L261">    final Rot xfBq = xfB.q;</span>
<span class="fc" id="L262">    final Rot xfAq = xfA.q;</span>
<span class="fc" id="L263">    final float cx = (xfBq.c * circlep.x - xfBq.s * circlep.y) + xfB.p.x;</span>
<span class="fc" id="L264">    final float cy = (xfBq.s * circlep.x + xfBq.c * circlep.y) + xfB.p.y;</span>
<span class="fc" id="L265">    final float px = cx - xfA.p.x;</span>
<span class="fc" id="L266">    final float py = cy - xfA.p.y;</span>
<span class="fc" id="L267">    final float cLocalx = (xfAq.c * px + xfAq.s * py);</span>
<span class="fc" id="L268">    final float cLocaly = (-xfAq.s * px + xfAq.c * py);</span>
    // end inline

    // Find the min separating edge.
<span class="fc" id="L272">    int normalIndex = 0;</span>
<span class="fc" id="L273">    float separation = -Float.MAX_VALUE;</span>
<span class="fc" id="L274">    final float radius = polygon.m_radius + circle.m_radius;</span>
<span class="fc" id="L275">    final int vertexCount = polygon.m_count;</span>
    float s;
<span class="fc" id="L277">    final Vec2[] vertices = polygon.m_vertices;</span>
<span class="fc" id="L278">    final Vec2[] normals = polygon.m_normals;</span>

<span class="fc bfc" id="L280" title="All 2 branches covered.">    for (int i = 0; i &lt; vertexCount; i++) {</span>
      // before inline
      // temp.set(cLocal).subLocal(vertices[i]);
      // float s = Vec2.dot(normals[i], temp);
      // after inline
<span class="fc" id="L285">      final Vec2 vertex = vertices[i];</span>
<span class="fc" id="L286">      final float tempx = cLocalx - vertex.x;</span>
<span class="fc" id="L287">      final float tempy = cLocaly - vertex.y;</span>
<span class="fc" id="L288">      s = normals[i].x * tempx + normals[i].y * tempy;</span>


<span class="fc bfc" id="L291" title="All 2 branches covered.">      if (s &gt; radius) {</span>
        // early out
<span class="fc" id="L293">        return;</span>
      }

<span class="fc bfc" id="L296" title="All 2 branches covered.">      if (s &gt; separation) {</span>
<span class="fc" id="L297">        separation = s;</span>
<span class="fc" id="L298">        normalIndex = i;</span>
      }
    }

    // Vertices that subtend the incident face.
<span class="fc" id="L303">    final int vertIndex1 = normalIndex;</span>
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">    final int vertIndex2 = vertIndex1 + 1 &lt; vertexCount ? vertIndex1 + 1 : 0;</span>
<span class="fc" id="L305">    final Vec2 v1 = vertices[vertIndex1];</span>
<span class="fc" id="L306">    final Vec2 v2 = vertices[vertIndex2];</span>

    // If the center is inside the polygon ...
<span class="fc bfc" id="L309" title="All 2 branches covered.">    if (separation &lt; Settings.EPSILON) {</span>
<span class="fc" id="L310">      manifold.pointCount = 1;</span>
<span class="fc" id="L311">      manifold.type = ManifoldType.FACE_A;</span>

      // before inline:
      // manifold.localNormal.set(normals[normalIndex]);
      // manifold.localPoint.set(v1).addLocal(v2).mulLocal(.5f);
      // manifold.points[0].localPoint.set(circle.m_p);
      // after inline:
<span class="fc" id="L318">      final Vec2 normal = normals[normalIndex];</span>
<span class="fc" id="L319">      manifold.localNormal.x = normal.x;</span>
<span class="fc" id="L320">      manifold.localNormal.y = normal.y;</span>
<span class="fc" id="L321">      manifold.localPoint.x = (v1.x + v2.x) * .5f;</span>
<span class="fc" id="L322">      manifold.localPoint.y = (v1.y + v2.y) * .5f;</span>
<span class="fc" id="L323">      final ManifoldPoint mpoint = manifold.points[0];</span>
<span class="fc" id="L324">      mpoint.localPoint.x = circlep.x;</span>
<span class="fc" id="L325">      mpoint.localPoint.y = circlep.y;</span>
<span class="fc" id="L326">      mpoint.id.zero();</span>
      // end inline

<span class="fc" id="L329">      return;</span>
    }

    // Compute barycentric coordinates
    // before inline:
    // temp.set(cLocal).subLocal(v1);
    // temp2.set(v2).subLocal(v1);
    // float u1 = Vec2.dot(temp, temp2);
    // temp.set(cLocal).subLocal(v2);
    // temp2.set(v1).subLocal(v2);
    // float u2 = Vec2.dot(temp, temp2);
    // after inline:
<span class="fc" id="L341">    final float tempX = cLocalx - v1.x;</span>
<span class="fc" id="L342">    final float tempY = cLocaly - v1.y;</span>
<span class="fc" id="L343">    final float temp2X = v2.x - v1.x;</span>
<span class="fc" id="L344">    final float temp2Y = v2.y - v1.y;</span>
<span class="fc" id="L345">    final float u1 = tempX * temp2X + tempY * temp2Y;</span>

<span class="fc" id="L347">    final float temp3X = cLocalx - v2.x;</span>
<span class="fc" id="L348">    final float temp3Y = cLocaly - v2.y;</span>
<span class="fc" id="L349">    final float temp4X = v1.x - v2.x;</span>
<span class="fc" id="L350">    final float temp4Y = v1.y - v2.y;</span>
<span class="fc" id="L351">    final float u2 = temp3X * temp4X + temp3Y * temp4Y;</span>
    // end inline

<span class="pc bpc" id="L354" title="1 of 2 branches missed.">    if (u1 &lt;= 0f) {</span>
      // inlined
<span class="nc" id="L356">      final float dx = cLocalx - v1.x;</span>
<span class="nc" id="L357">      final float dy = cLocaly - v1.y;</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">      if (dx * dx + dy * dy &gt; radius * radius) {</span>
<span class="nc" id="L359">        return;</span>
      }

<span class="nc" id="L362">      manifold.pointCount = 1;</span>
<span class="nc" id="L363">      manifold.type = ManifoldType.FACE_A;</span>
      // before inline:
      // manifold.localNormal.set(cLocal).subLocal(v1);
      // after inline:
<span class="nc" id="L367">      manifold.localNormal.x = cLocalx - v1.x;</span>
<span class="nc" id="L368">      manifold.localNormal.y = cLocaly - v1.y;</span>
      // end inline
<span class="nc" id="L370">      manifold.localNormal.normalize();</span>
<span class="nc" id="L371">      manifold.localPoint.set(v1);</span>
<span class="nc" id="L372">      manifold.points[0].localPoint.set(circlep);</span>
<span class="nc" id="L373">      manifold.points[0].id.zero();</span>
<span class="pc bfc" id="L374" title="All 2 branches covered.">    } else if (u2 &lt;= 0.0f) {</span>
      // inlined
<span class="fc" id="L376">      final float dx = cLocalx - v2.x;</span>
<span class="fc" id="L377">      final float dy = cLocaly - v2.y;</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">      if (dx * dx + dy * dy &gt; radius * radius) {</span>
<span class="fc" id="L379">        return;</span>
      }

<span class="fc" id="L382">      manifold.pointCount = 1;</span>
<span class="fc" id="L383">      manifold.type = ManifoldType.FACE_A;</span>
      // before inline:
      // manifold.localNormal.set(cLocal).subLocal(v2);
      // after inline:
<span class="fc" id="L387">      manifold.localNormal.x = cLocalx - v2.x;</span>
<span class="fc" id="L388">      manifold.localNormal.y = cLocaly - v2.y;</span>
      // end inline
<span class="fc" id="L390">      manifold.localNormal.normalize();</span>
<span class="fc" id="L391">      manifold.localPoint.set(v2);</span>
<span class="fc" id="L392">      manifold.points[0].localPoint.set(circlep);</span>
<span class="fc" id="L393">      manifold.points[0].id.zero();</span>
<span class="fc" id="L394">    } else {</span>
      // Vec2 faceCenter = 0.5f * (v1 + v2);
      // (temp is faceCenter)
      // before inline:
      // temp.set(v1).addLocal(v2).mulLocal(.5f);
      //
      // temp2.set(cLocal).subLocal(temp);
      // separation = Vec2.dot(temp2, normals[vertIndex1]);
      // if (separation &gt; radius) {
      // return;
      // }
      // after inline:
<span class="fc" id="L406">      final float fcx = (v1.x + v2.x) * .5f;</span>
<span class="fc" id="L407">      final float fcy = (v1.y + v2.y) * .5f;</span>

<span class="fc" id="L409">      final float tx = cLocalx - fcx;</span>
<span class="fc" id="L410">      final float ty = cLocaly - fcy;</span>
<span class="fc" id="L411">      final Vec2 normal = normals[vertIndex1];</span>
<span class="fc" id="L412">      separation = tx * normal.x + ty * normal.y;</span>
<span class="pc bpc" id="L413" title="1 of 2 branches missed.">      if (separation &gt; radius) {</span>
<span class="nc" id="L414">        return;</span>
      }
      // end inline

<span class="fc" id="L418">      manifold.pointCount = 1;</span>
<span class="fc" id="L419">      manifold.type = ManifoldType.FACE_A;</span>
<span class="fc" id="L420">      manifold.localNormal.set(normals[vertIndex1]);</span>
<span class="fc" id="L421">      manifold.localPoint.x = fcx; // (faceCenter)</span>
<span class="fc" id="L422">      manifold.localPoint.y = fcy;</span>
<span class="fc" id="L423">      manifold.points[0].localPoint.set(circlep);</span>
<span class="fc" id="L424">      manifold.points[0].id.zero();</span>
    }
<span class="fc" id="L426">  }</span>

  /**
   * Find the separation between poly1 and poly2 for a given edge normal on poly1.
   * 
   * @param poly1
   * @param xf1
   * @param edge1
   * @param poly2
   * @param xf2
   */
  public final float edgeSeparation(final PolygonShape poly1, final Transform xf1, final int edge1,
      final PolygonShape poly2, final Transform xf2) {

<span class="fc" id="L440">    final int count1 = poly1.m_count;</span>
<span class="fc" id="L441">    final Vec2[] vertices1 = poly1.m_vertices;</span>
<span class="fc" id="L442">    final Vec2[] normals1 = poly1.m_normals;</span>

<span class="fc" id="L444">    final int count2 = poly2.m_count;</span>
<span class="fc" id="L445">    final Vec2[] vertices2 = poly2.m_vertices;</span>

<span class="pc bpc" id="L447" title="1 of 6 branches missed.">    assert (0 &lt;= edge1 &amp;&amp; edge1 &lt; count1);</span>
    // Convert normal from poly1's frame into poly2's frame.
    // before inline:
    // // Vec2 normal1World = Mul(xf1.R, normals1[edge1]);
    // Rot.mulToOutUnsafe(xf1.q, normals1[edge1], normal1World);
    // // Vec2 normal1 = MulT(xf2.R, normal1World);
    // Rot.mulTransUnsafe(xf2.q, normal1World, normal1);
    // final float normal1x = normal1.x;
    // final float normal1y = normal1.y;
    // final float normal1Worldx = normal1World.x;
    // final float normal1Worldy = normal1World.y;
    // after inline:
<span class="fc" id="L459">    final Rot xf1q = xf1.q;</span>
<span class="fc" id="L460">    final Rot xf2q = xf2.q;</span>
<span class="fc" id="L461">    Rot q = xf1q;</span>
<span class="fc" id="L462">    Vec2 v = normals1[edge1];</span>
<span class="fc" id="L463">    final float normal1Worldx = q.c * v.x - q.s * v.y;</span>
<span class="fc" id="L464">    final float normal1Worldy = q.s * v.x + q.c * v.y;</span>
<span class="fc" id="L465">    Rot q1 = xf2q;</span>
<span class="fc" id="L466">    final float normal1x = q1.c * normal1Worldx + q1.s * normal1Worldy;</span>
<span class="fc" id="L467">    final float normal1y = -q1.s * normal1Worldx + q1.c * normal1Worldy;</span>
    // end inline

    // Find support vertex on poly2 for -normal.
<span class="fc" id="L471">    int index = 0;</span>
<span class="fc" id="L472">    float minDot = Float.MAX_VALUE;</span>

<span class="fc bfc" id="L474" title="All 2 branches covered.">    for (int i = 0; i &lt; count2; ++i) {</span>
<span class="fc" id="L475">      final Vec2 a = vertices2[i];</span>
<span class="fc" id="L476">      final float dot = a.x * normal1x + a.y * normal1y;</span>
<span class="fc bfc" id="L477" title="All 2 branches covered.">      if (dot &lt; minDot) {</span>
<span class="fc" id="L478">        minDot = dot;</span>
<span class="fc" id="L479">        index = i;</span>
      }
    }

    // Vec2 v1 = Mul(xf1, vertices1[edge1]);
    // Vec2 v2 = Mul(xf2, vertices2[index]);
    // before inline:
    // Transform.mulToOut(xf1, vertices1[edge1], v1);
    // Transform.mulToOut(xf2, vertices2[index], v2);
    //
    // float separation = Vec2.dot(v2.subLocal(v1), normal1World);
    // return separation;

    // after inline:
<span class="fc" id="L493">    Vec2 v3 = vertices1[edge1];</span>
<span class="fc" id="L494">    final float v1x = (xf1q.c * v3.x - xf1q.s * v3.y) + xf1.p.x;</span>
<span class="fc" id="L495">    final float v1y = (xf1q.s * v3.x + xf1q.c * v3.y) + xf1.p.y;</span>
<span class="fc" id="L496">    Vec2 v4 = vertices2[index];</span>
<span class="fc" id="L497">    final float v2x = (xf2q.c * v4.x - xf2q.s * v4.y) + xf2.p.x - v1x;</span>
<span class="fc" id="L498">    final float v2y = (xf2q.s * v4.x + xf2q.c * v4.y) + xf2.p.y - v1y;</span>

<span class="fc" id="L500">    float separation = v2x * normal1Worldx + v2y * normal1Worldy;</span>
<span class="fc" id="L501">    return separation;</span>
    // end inline
  }

  // djm pooling, and from above
<span class="fc" id="L506">  private final Vec2 temp = new Vec2();</span>

  /**
   * Find the max separation between poly1 and poly2 using edge normals from poly1.
   * 
   * @param results
   * @param poly1
   * @param xf1
   * @param poly2
   * @param xf2
   * @return
   */
  public final void findMaxSeparation(EdgeResults results, final PolygonShape poly1,
      final Transform xf1, final PolygonShape poly2, final Transform xf2) {
<span class="fc" id="L520">    int count1 = poly1.m_count;</span>
<span class="fc" id="L521">    final Vec2[] normals1 = poly1.m_normals;</span>

<span class="fc" id="L523">    final Vec2 poly1centroid = poly1.m_centroid;</span>
<span class="fc" id="L524">    final Vec2 poly2centroid = poly2.m_centroid;</span>
<span class="fc" id="L525">    final Rot xf2q = xf2.q;</span>
<span class="fc" id="L526">    final Rot xf1q = xf1.q;</span>
    // Vector pointing from the centroid of poly1 to the centroid of poly2.
    // before inline:
    // Transform.mulToOutUnsafe(xf2, poly2centroid, d);
    // Transform.mulToOutUnsafe(xf1, poly1centroid, temp);
    // d.subLocal(temp);
    //
    // Rot.mulTransUnsafe(xf1q, d, dLocal1);
    // after inline:
<span class="fc" id="L535">    float dx = (xf2q.c * poly2centroid.x - xf2q.s * poly2centroid.y) + xf2.p.x;</span>
<span class="fc" id="L536">    float dy = (xf2q.s * poly2centroid.x + xf2q.c * poly2centroid.y) + xf2.p.y;</span>
<span class="fc" id="L537">    dx -= (xf1q.c * poly1centroid.x - xf1q.s * poly1centroid.y) + xf1.p.x;</span>
<span class="fc" id="L538">    dy -= (xf1q.s * poly1centroid.x + xf1q.c * poly1centroid.y) + xf1.p.y;</span>

<span class="fc" id="L540">    final float dLocal1x = xf1q.c * dx + xf1q.s * dy;</span>
<span class="fc" id="L541">    final float dLocal1y = -xf1q.s * dx + xf1q.c * dy;</span>
    // end inline

    // Find edge normal on poly1 that has the largest projection onto d.
<span class="fc" id="L545">    int edge = 0;</span>
    float dot;
<span class="fc" id="L547">    float maxDot = -Float.MAX_VALUE;</span>
<span class="fc bfc" id="L548" title="All 2 branches covered.">    for (int i = 0; i &lt; count1; i++) {</span>
<span class="fc" id="L549">      final Vec2 normal = normals1[i];</span>
<span class="fc" id="L550">      dot = normal.x * dLocal1x + normal.y * dLocal1y;</span>
<span class="fc bfc" id="L551" title="All 2 branches covered.">      if (dot &gt; maxDot) {</span>
<span class="fc" id="L552">        maxDot = dot;</span>
<span class="fc" id="L553">        edge = i;</span>
      }
    }

    // Get the separation for the edge normal.
<span class="fc" id="L558">    float s = edgeSeparation(poly1, xf1, edge, poly2, xf2);</span>

    // Check the separation for the previous edge normal.
<span class="fc bfc" id="L561" title="All 2 branches covered.">    int prevEdge = edge - 1 &gt;= 0 ? edge - 1 : count1 - 1;</span>
<span class="fc" id="L562">    float sPrev = edgeSeparation(poly1, xf1, prevEdge, poly2, xf2);</span>

    // Check the separation for the next edge normal.
<span class="fc bfc" id="L565" title="All 2 branches covered.">    int nextEdge = edge + 1 &lt; count1 ? edge + 1 : 0;</span>
<span class="fc" id="L566">    float sNext = edgeSeparation(poly1, xf1, nextEdge, poly2, xf2);</span>

    // Find the best edge and the search direction.
    int bestEdge;
    float bestSeparation;
    int increment;
<span class="pc bpc" id="L572" title="3 of 4 branches missed.">    if (sPrev &gt; s &amp;&amp; sPrev &gt; sNext) {</span>
<span class="nc" id="L573">      increment = -1;</span>
<span class="nc" id="L574">      bestEdge = prevEdge;</span>
<span class="nc" id="L575">      bestSeparation = sPrev;</span>
<span class="pc bpc" id="L576" title="1 of 2 branches missed.">    } else if (sNext &gt; s) {</span>
<span class="nc" id="L577">      increment = 1;</span>
<span class="nc" id="L578">      bestEdge = nextEdge;</span>
<span class="nc" id="L579">      bestSeparation = sNext;</span>
    } else {
<span class="fc" id="L581">      results.edgeIndex = edge;</span>
<span class="fc" id="L582">      results.separation = s;</span>
<span class="fc" id="L583">      return;</span>
    }

    // Perform a local search for the best edge normal.
    for (;;) {
<span class="nc bnc" id="L588" title="All 2 branches missed.">      if (increment == -1) {</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">        edge = bestEdge - 1 &gt;= 0 ? bestEdge - 1 : count1 - 1;</span>
      } else {
<span class="nc bnc" id="L591" title="All 2 branches missed.">        edge = bestEdge + 1 &lt; count1 ? bestEdge + 1 : 0;</span>
      }

<span class="nc" id="L594">      s = edgeSeparation(poly1, xf1, edge, poly2, xf2);</span>

<span class="nc bnc" id="L596" title="All 2 branches missed.">      if (s &gt; bestSeparation) {</span>
<span class="nc" id="L597">        bestEdge = edge;</span>
<span class="nc" id="L598">        bestSeparation = s;</span>
      } else {
        break;
      }
    }

<span class="nc" id="L604">    results.edgeIndex = bestEdge;</span>
<span class="nc" id="L605">    results.separation = bestSeparation;</span>
<span class="nc" id="L606">  }</span>


  public final void findIncidentEdge(final ClipVertex[] c, final PolygonShape poly1,
      final Transform xf1, int edge1, final PolygonShape poly2, final Transform xf2) {
<span class="fc" id="L611">    int count1 = poly1.m_count;</span>
<span class="fc" id="L612">    final Vec2[] normals1 = poly1.m_normals;</span>

<span class="fc" id="L614">    int count2 = poly2.m_count;</span>
<span class="fc" id="L615">    final Vec2[] vertices2 = poly2.m_vertices;</span>
<span class="fc" id="L616">    final Vec2[] normals2 = poly2.m_normals;</span>

<span class="pc bpc" id="L618" title="3 of 6 branches missed.">    assert (0 &lt;= edge1 &amp;&amp; edge1 &lt; count1);</span>

<span class="fc" id="L620">    final ClipVertex c0 = c[0];</span>
<span class="fc" id="L621">    final ClipVertex c1 = c[1];</span>
<span class="fc" id="L622">    final Rot xf1q = xf1.q;</span>
<span class="fc" id="L623">    final Rot xf2q = xf2.q;</span>

    // Get the normal of the reference edge in poly2's frame.
    // Vec2 normal1 = MulT(xf2.R, Mul(xf1.R, normals1[edge1]));
    // before inline:
    // Rot.mulToOutUnsafe(xf1.q, normals1[edge1], normal1); // temporary
    // Rot.mulTrans(xf2.q, normal1, normal1);
    // after inline:
<span class="fc" id="L631">    final Vec2 v = normals1[edge1];</span>
<span class="fc" id="L632">    final float tempx = xf1q.c * v.x - xf1q.s * v.y;</span>
<span class="fc" id="L633">    final float tempy = xf1q.s * v.x + xf1q.c * v.y;</span>
<span class="fc" id="L634">    final float normal1x = xf2q.c * tempx + xf2q.s * tempy;</span>
<span class="fc" id="L635">    final float normal1y = -xf2q.s * tempx + xf2q.c * tempy;</span>

    // end inline

    // Find the incident edge on poly2.
<span class="fc" id="L640">    int index = 0;</span>
<span class="fc" id="L641">    float minDot = Float.MAX_VALUE;</span>
<span class="fc bfc" id="L642" title="All 2 branches covered.">    for (int i = 0; i &lt; count2; ++i) {</span>
<span class="fc" id="L643">      Vec2 b = normals2[i];</span>
<span class="fc" id="L644">      float dot = normal1x * b.x + normal1y * b.y;</span>
<span class="fc bfc" id="L645" title="All 2 branches covered.">      if (dot &lt; minDot) {</span>
<span class="fc" id="L646">        minDot = dot;</span>
<span class="fc" id="L647">        index = i;</span>
      }
    }

    // Build the clip vertices for the incident edge.
<span class="fc" id="L652">    int i1 = index;</span>
<span class="fc bfc" id="L653" title="All 2 branches covered.">    int i2 = i1 + 1 &lt; count2 ? i1 + 1 : 0;</span>

    // c0.v = Mul(xf2, vertices2[i1]);
<span class="fc" id="L656">    Vec2 v1 = vertices2[i1];</span>
<span class="fc" id="L657">    Vec2 out = c0.v;</span>
<span class="fc" id="L658">    out.x = (xf2q.c * v1.x - xf2q.s * v1.y) + xf2.p.x;</span>
<span class="fc" id="L659">    out.y = (xf2q.s * v1.x + xf2q.c * v1.y) + xf2.p.y;</span>
<span class="fc" id="L660">    c0.id.indexA = (byte) edge1;</span>
<span class="fc" id="L661">    c0.id.indexB = (byte) i1;</span>
<span class="fc" id="L662">    c0.id.typeA = (byte) ContactID.Type.FACE.ordinal();</span>
<span class="fc" id="L663">    c0.id.typeB = (byte) ContactID.Type.VERTEX.ordinal();</span>

    // c1.v = Mul(xf2, vertices2[i2]);
<span class="fc" id="L666">    Vec2 v2 = vertices2[i2];</span>
<span class="fc" id="L667">    Vec2 out1 = c1.v;</span>
<span class="fc" id="L668">    out1.x = (xf2q.c * v2.x - xf2q.s * v2.y) + xf2.p.x;</span>
<span class="fc" id="L669">    out1.y = (xf2q.s * v2.x + xf2q.c * v2.y) + xf2.p.y;</span>
<span class="fc" id="L670">    c1.id.indexA = (byte) edge1;</span>
<span class="fc" id="L671">    c1.id.indexB = (byte) i2;</span>
<span class="fc" id="L672">    c1.id.typeA = (byte) ContactID.Type.FACE.ordinal();</span>
<span class="fc" id="L673">    c1.id.typeB = (byte) ContactID.Type.VERTEX.ordinal();</span>
<span class="fc" id="L674">  }</span>

<span class="fc" id="L676">  private final EdgeResults results1 = new EdgeResults();</span>
<span class="fc" id="L677">  private final EdgeResults results2 = new EdgeResults();</span>
<span class="fc" id="L678">  private final ClipVertex[] incidentEdge = new ClipVertex[2];</span>
<span class="fc" id="L679">  private final Vec2 localTangent = new Vec2();</span>
<span class="fc" id="L680">  private final Vec2 localNormal = new Vec2();</span>
<span class="fc" id="L681">  private final Vec2 planePoint = new Vec2();</span>
<span class="fc" id="L682">  private final Vec2 tangent = new Vec2();</span>
<span class="fc" id="L683">  private final Vec2 v11 = new Vec2();</span>
<span class="fc" id="L684">  private final Vec2 v12 = new Vec2();</span>
<span class="fc" id="L685">  private final ClipVertex[] clipPoints1 = new ClipVertex[2];</span>
<span class="fc" id="L686">  private final ClipVertex[] clipPoints2 = new ClipVertex[2];</span>

  /**
   * Compute the collision manifold between two polygons.
   * 
   * @param manifold
   * @param polyA
   * @param xfA
   * @param polyB
   * @param xfB
   */
  public final void collidePolygons(Manifold manifold, final PolygonShape polyA,
      final Transform xfA, final PolygonShape polyB, final Transform xfB) {
    // Find edge normal of max separation on A - return if separating axis is found
    // Find edge normal of max separation on B - return if separation axis is found
    // Choose reference edge as min(minA, minB)
    // Find incident edge
    // Clip

    // The normal points from 1 to 2

<span class="fc" id="L707">    manifold.pointCount = 0;</span>
<span class="fc" id="L708">    float totalRadius = polyA.m_radius + polyB.m_radius;</span>

<span class="fc" id="L710">    findMaxSeparation(results1, polyA, xfA, polyB, xfB);</span>
<span class="fc bfc" id="L711" title="All 2 branches covered.">    if (results1.separation &gt; totalRadius) {</span>
<span class="fc" id="L712">      return;</span>
    }

<span class="fc" id="L715">    findMaxSeparation(results2, polyB, xfB, polyA, xfA);</span>
<span class="fc bfc" id="L716" title="All 2 branches covered.">    if (results2.separation &gt; totalRadius) {</span>
<span class="fc" id="L717">      return;</span>
    }

    final PolygonShape poly1; // reference polygon
    final PolygonShape poly2; // incident polygon
    Transform xf1, xf2;
    int edge1; // reference edge
    boolean flip;
<span class="fc" id="L725">    final float k_relativeTol = 0.98f;</span>
<span class="fc" id="L726">    final float k_absoluteTol = 0.001f;</span>

<span class="pc bpc" id="L728" title="1 of 2 branches missed.">    if (results2.separation &gt; k_relativeTol * results1.separation + k_absoluteTol) {</span>
<span class="nc" id="L729">      poly1 = polyB;</span>
<span class="nc" id="L730">      poly2 = polyA;</span>
<span class="nc" id="L731">      xf1 = xfB;</span>
<span class="nc" id="L732">      xf2 = xfA;</span>
<span class="nc" id="L733">      edge1 = results2.edgeIndex;</span>
<span class="nc" id="L734">      manifold.type = ManifoldType.FACE_B;</span>
<span class="nc" id="L735">      flip = true;</span>
    } else {
<span class="fc" id="L737">      poly1 = polyA;</span>
<span class="fc" id="L738">      poly2 = polyB;</span>
<span class="fc" id="L739">      xf1 = xfA;</span>
<span class="fc" id="L740">      xf2 = xfB;</span>
<span class="fc" id="L741">      edge1 = results1.edgeIndex;</span>
<span class="fc" id="L742">      manifold.type = ManifoldType.FACE_A;</span>
<span class="fc" id="L743">      flip = false;</span>
    }
<span class="fc" id="L745">    final Rot xf1q = xf1.q;</span>

<span class="fc" id="L747">    findIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);</span>

<span class="fc" id="L749">    int count1 = poly1.m_count;</span>
<span class="fc" id="L750">    final Vec2[] vertices1 = poly1.m_vertices;</span>

<span class="fc" id="L752">    final int iv1 = edge1;</span>
<span class="fc bfc" id="L753" title="All 2 branches covered.">    final int iv2 = edge1 + 1 &lt; count1 ? edge1 + 1 : 0;</span>
<span class="fc" id="L754">    v11.set(vertices1[iv1]);</span>
<span class="fc" id="L755">    v12.set(vertices1[iv2]);</span>
<span class="fc" id="L756">    localTangent.x = v12.x - v11.x;</span>
<span class="fc" id="L757">    localTangent.y = v12.y - v11.y;</span>
<span class="fc" id="L758">    localTangent.normalize();</span>

    // Vec2 localNormal = Vec2.cross(dv, 1.0f);
<span class="fc" id="L761">    localNormal.x = 1f * localTangent.y;</span>
<span class="fc" id="L762">    localNormal.y = -1f * localTangent.x;</span>

    // Vec2 planePoint = 0.5f * (v11+ v12);
<span class="fc" id="L765">    planePoint.x = (v11.x + v12.x) * .5f;</span>
<span class="fc" id="L766">    planePoint.y = (v11.y + v12.y) * .5f;</span>

    // Rot.mulToOutUnsafe(xf1.q, localTangent, tangent);
<span class="fc" id="L769">    tangent.x = xf1q.c * localTangent.x - xf1q.s * localTangent.y;</span>
<span class="fc" id="L770">    tangent.y = xf1q.s * localTangent.x + xf1q.c * localTangent.y;</span>

    // Vec2.crossToOutUnsafe(tangent, 1f, normal);
<span class="fc" id="L773">    final float normalx = 1f * tangent.y;</span>
<span class="fc" id="L774">    final float normaly = -1f * tangent.x;</span>


<span class="fc" id="L777">    Transform.mulToOut(xf1, v11, v11);</span>
<span class="fc" id="L778">    Transform.mulToOut(xf1, v12, v12);</span>
    // v11 = Mul(xf1, v11);
    // v12 = Mul(xf1, v12);

    // Face offset
    // float frontOffset = Vec2.dot(normal, v11);
<span class="fc" id="L784">    float frontOffset = normalx * v11.x + normaly * v11.y;</span>

    // Side offsets, extended by polytope skin thickness.
    // float sideOffset1 = -Vec2.dot(tangent, v11) + totalRadius;
    // float sideOffset2 = Vec2.dot(tangent, v12) + totalRadius;
<span class="fc" id="L789">    float sideOffset1 = -(tangent.x * v11.x + tangent.y * v11.y) + totalRadius;</span>
<span class="fc" id="L790">    float sideOffset2 = tangent.x * v12.x + tangent.y * v12.y + totalRadius;</span>

    // Clip incident edge against extruded edge1 side edges.
    // ClipVertex clipPoints1[2];
    // ClipVertex clipPoints2[2];
    int np;

    // Clip to box side 1
    // np = ClipSegmentToLine(clipPoints1, incidentEdge, -sideNormal, sideOffset1);
<span class="fc" id="L799">    tangent.negateLocal();</span>
<span class="fc" id="L800">    np = clipSegmentToLine(clipPoints1, incidentEdge, tangent, sideOffset1, iv1);</span>
<span class="fc" id="L801">    tangent.negateLocal();</span>

<span class="pc bpc" id="L803" title="1 of 2 branches missed.">    if (np &lt; 2) {</span>
<span class="nc" id="L804">      return;</span>
    }

    // Clip to negative box side 1
<span class="fc" id="L808">    np = clipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2, iv2);</span>

<span class="pc bpc" id="L810" title="1 of 2 branches missed.">    if (np &lt; 2) {</span>
<span class="nc" id="L811">      return;</span>
    }

    // Now clipPoints2 contains the clipped points.
<span class="fc" id="L815">    manifold.localNormal.set(localNormal);</span>
<span class="fc" id="L816">    manifold.localPoint.set(planePoint);</span>

<span class="fc" id="L818">    int pointCount = 0;</span>
<span class="fc bfc" id="L819" title="All 2 branches covered.">    for (int i = 0; i &lt; Settings.maxManifoldPoints; ++i) {</span>
      // float separation = Vec2.dot(normal, clipPoints2[i].v) - frontOffset;
<span class="fc" id="L821">      float separation = normalx * clipPoints2[i].v.x + normaly * clipPoints2[i].v.y - frontOffset;</span>

<span class="fc bfc" id="L823" title="All 2 branches covered.">      if (separation &lt;= totalRadius) {</span>
<span class="fc" id="L824">        ManifoldPoint cp = manifold.points[pointCount];</span>
        // cp.m_localPoint = MulT(xf2, clipPoints2[i].v);
<span class="fc" id="L826">        Vec2 out = cp.localPoint;</span>
<span class="fc" id="L827">        final float px = clipPoints2[i].v.x - xf2.p.x;</span>
<span class="fc" id="L828">        final float py = clipPoints2[i].v.y - xf2.p.y;</span>
<span class="fc" id="L829">        out.x = (xf2.q.c * px + xf2.q.s * py);</span>
<span class="fc" id="L830">        out.y = (-xf2.q.s * px + xf2.q.c * py);</span>
<span class="fc" id="L831">        cp.id.set(clipPoints2[i].id);</span>
<span class="pc bpc" id="L832" title="1 of 2 branches missed.">        if (flip) {</span>
          // Swap features
<span class="nc" id="L834">          cp.id.flip();</span>
        }
<span class="fc" id="L836">        ++pointCount;</span>
      }
    }

<span class="fc" id="L840">    manifold.pointCount = pointCount;</span>
<span class="fc" id="L841">  }</span>

<span class="fc" id="L843">  private final Vec2 Q = new Vec2();</span>
<span class="fc" id="L844">  private final Vec2 e = new Vec2();</span>
<span class="fc" id="L845">  private final ContactID cf = new ContactID();</span>
<span class="fc" id="L846">  private final Vec2 e1 = new Vec2();</span>
<span class="fc" id="L847">  private final Vec2 P = new Vec2();</span>
<span class="fc" id="L848">  private final Vec2 n = new Vec2();</span>

  // Compute contact points for edge versus circle.
  // This accounts for edge connectivity.
  public void collideEdgeAndCircle(Manifold manifold, final EdgeShape edgeA, final Transform xfA,
      final CircleShape circleB, final Transform xfB) {
<span class="fc" id="L854">    manifold.pointCount = 0;</span>


    // Compute circle in frame of edge
    // Vec2 Q = MulT(xfA, Mul(xfB, circleB.m_p));
<span class="fc" id="L859">    Transform.mulToOutUnsafe(xfB, circleB.m_p, temp);</span>
<span class="fc" id="L860">    Transform.mulTransToOutUnsafe(xfA, temp, Q);</span>

<span class="fc" id="L862">    final Vec2 A = edgeA.m_vertex1;</span>
<span class="fc" id="L863">    final Vec2 B = edgeA.m_vertex2;</span>
<span class="fc" id="L864">    e.set(B).subLocal(A);</span>

    // Barycentric coordinates
<span class="fc" id="L867">    float u = Vec2.dot(e, temp.set(B).subLocal(Q));</span>
<span class="fc" id="L868">    float v = Vec2.dot(e, temp.set(Q).subLocal(A));</span>

<span class="fc" id="L870">    float radius = edgeA.m_radius + circleB.m_radius;</span>

    // ContactFeature cf;
<span class="fc" id="L873">    cf.indexB = 0;</span>
<span class="fc" id="L874">    cf.typeB = (byte) ContactID.Type.VERTEX.ordinal();</span>

    // Region A
<span class="fc bfc" id="L877" title="All 2 branches covered.">    if (v &lt;= 0.0f) {</span>
<span class="fc" id="L878">      final Vec2 P = A;</span>
<span class="fc" id="L879">      d.set(Q).subLocal(P);</span>
<span class="fc" id="L880">      float dd = Vec2.dot(d, d);</span>
<span class="pc bpc" id="L881" title="1 of 2 branches missed.">      if (dd &gt; radius * radius) {</span>
<span class="fc" id="L882">        return;</span>
      }

      // Is there an edge connected to A?
<span class="nc bnc" id="L886" title="All 2 branches missed.">      if (edgeA.m_hasVertex0) {</span>
<span class="nc" id="L887">        final Vec2 A1 = edgeA.m_vertex0;</span>
<span class="nc" id="L888">        final Vec2 B1 = A;</span>
<span class="nc" id="L889">        e1.set(B1).subLocal(A1);</span>
<span class="nc" id="L890">        float u1 = Vec2.dot(e1, temp.set(B1).subLocal(Q));</span>

        // Is the circle in Region AB of the previous edge?
<span class="nc bnc" id="L893" title="All 2 branches missed.">        if (u1 &gt; 0.0f) {</span>
<span class="nc" id="L894">          return;</span>
        }
      }

<span class="nc" id="L898">      cf.indexA = 0;</span>
<span class="nc" id="L899">      cf.typeA = (byte) ContactID.Type.VERTEX.ordinal();</span>
<span class="nc" id="L900">      manifold.pointCount = 1;</span>
<span class="nc" id="L901">      manifold.type = Manifold.ManifoldType.CIRCLES;</span>
<span class="nc" id="L902">      manifold.localNormal.setZero();</span>
<span class="nc" id="L903">      manifold.localPoint.set(P);</span>
      // manifold.points[0].id.key = 0;
<span class="nc" id="L905">      manifold.points[0].id.set(cf);</span>
<span class="nc" id="L906">      manifold.points[0].localPoint.set(circleB.m_p);</span>
<span class="nc" id="L907">      return;</span>
    }

    // Region B
<span class="fc bfc" id="L911" title="All 2 branches covered.">    if (u &lt;= 0.0f) {</span>
<span class="fc" id="L912">      Vec2 P = B;</span>
<span class="fc" id="L913">      d.set(Q).subLocal(P);</span>
<span class="fc" id="L914">      float dd = Vec2.dot(d, d);</span>
<span class="pc bpc" id="L915" title="1 of 2 branches missed.">      if (dd &gt; radius * radius) {</span>
<span class="nc" id="L916">        return;</span>
      }

      // Is there an edge connected to B?
<span class="fc bfc" id="L920" title="All 2 branches covered.">      if (edgeA.m_hasVertex3) {</span>
<span class="fc" id="L921">        final Vec2 B2 = edgeA.m_vertex3;</span>
<span class="fc" id="L922">        final Vec2 A2 = B;</span>
<span class="fc" id="L923">        final Vec2 e2 = e1;</span>
<span class="fc" id="L924">        e2.set(B2).subLocal(A2);</span>
<span class="fc" id="L925">        float v2 = Vec2.dot(e2, temp.set(Q).subLocal(A2));</span>

        // Is the circle in Region AB of the next edge?
<span class="pc bpc" id="L928" title="1 of 2 branches missed.">        if (v2 &gt; 0.0f) {</span>
<span class="nc" id="L929">          return;</span>
        }
      }

<span class="fc" id="L933">      cf.indexA = 1;</span>
<span class="fc" id="L934">      cf.typeA = (byte) ContactID.Type.VERTEX.ordinal();</span>
<span class="fc" id="L935">      manifold.pointCount = 1;</span>
<span class="fc" id="L936">      manifold.type = Manifold.ManifoldType.CIRCLES;</span>
<span class="fc" id="L937">      manifold.localNormal.setZero();</span>
<span class="fc" id="L938">      manifold.localPoint.set(P);</span>
      // manifold.points[0].id.key = 0;
<span class="fc" id="L940">      manifold.points[0].id.set(cf);</span>
<span class="fc" id="L941">      manifold.points[0].localPoint.set(circleB.m_p);</span>
<span class="fc" id="L942">      return;</span>
    }

    // Region AB
<span class="fc" id="L946">    float den = Vec2.dot(e, e);</span>
<span class="pc bpc" id="L947" title="2 of 4 branches missed.">    assert (den &gt; 0.0f);</span>

    // Vec2 P = (1.0f / den) * (u * A + v * B);
<span class="fc" id="L950">    P.set(A).mulLocal(u).addLocal(temp.set(B).mulLocal(v));</span>
<span class="fc" id="L951">    P.mulLocal(1.0f / den);</span>
<span class="fc" id="L952">    d.set(Q).subLocal(P);</span>
<span class="fc" id="L953">    float dd = Vec2.dot(d, d);</span>
<span class="fc bfc" id="L954" title="All 2 branches covered.">    if (dd &gt; radius * radius) {</span>
<span class="fc" id="L955">      return;</span>
    }

<span class="fc" id="L958">    n.x = -e.y;</span>
<span class="fc" id="L959">    n.y = e.x;</span>
<span class="fc bfc" id="L960" title="All 2 branches covered.">    if (Vec2.dot(n, temp.set(Q).subLocal(A)) &lt; 0.0f) {</span>
<span class="fc" id="L961">      n.set(-n.x, -n.y);</span>
    }
<span class="fc" id="L963">    n.normalize();</span>

<span class="fc" id="L965">    cf.indexA = 0;</span>
<span class="fc" id="L966">    cf.typeA = (byte) ContactID.Type.FACE.ordinal();</span>
<span class="fc" id="L967">    manifold.pointCount = 1;</span>
<span class="fc" id="L968">    manifold.type = Manifold.ManifoldType.FACE_A;</span>
<span class="fc" id="L969">    manifold.localNormal.set(n);</span>
<span class="fc" id="L970">    manifold.localPoint.set(A);</span>
    // manifold.points[0].id.key = 0;
<span class="fc" id="L972">    manifold.points[0].id.set(cf);</span>
<span class="fc" id="L973">    manifold.points[0].localPoint.set(circleB.m_p);</span>
<span class="fc" id="L974">  }</span>

<span class="fc" id="L976">  private final EPCollider collider = new EPCollider();</span>

  public void collideEdgeAndPolygon(Manifold manifold, final EdgeShape edgeA, final Transform xfA,
      final PolygonShape polygonB, final Transform xfB) {
<span class="fc" id="L980">    collider.collide(manifold, edgeA, xfA, polygonB, xfB);</span>
<span class="fc" id="L981">  }</span>



  /**
   * Java-specific class for returning edge results
   */
  private static class EdgeResults {
    public float separation;
    public int edgeIndex;
  }

  /**
   * Used for computing contact manifolds.
   */
  public static class ClipVertex {
    public final Vec2 v;
    public final ContactID id;

<span class="fc" id="L1000">    public ClipVertex() {</span>
<span class="fc" id="L1001">      v = new Vec2();</span>
<span class="fc" id="L1002">      id = new ContactID();</span>
<span class="fc" id="L1003">    }</span>

    public void set(final ClipVertex cv) {
<span class="fc" id="L1006">      Vec2 v1 = cv.v;</span>
<span class="fc" id="L1007">      v.x = v1.x;</span>
<span class="fc" id="L1008">      v.y = v1.y;</span>
<span class="fc" id="L1009">      ContactID c = cv.id;</span>
<span class="fc" id="L1010">      id.indexA = c.indexA;</span>
<span class="fc" id="L1011">      id.indexB = c.indexB;</span>
<span class="fc" id="L1012">      id.typeA = c.typeA;</span>
<span class="fc" id="L1013">      id.typeB = c.typeB;</span>
<span class="fc" id="L1014">    }</span>
  }

  /**
   * This is used for determining the state of contact points.
   * 
   * @author Daniel Murphy
   */
<span class="fc" id="L1022">  public static enum PointState {</span>
    /**
     * point does not exist
     */
<span class="fc" id="L1026">    NULL_STATE,</span>
    /**
     * point was added in the update
     */
<span class="fc" id="L1030">    ADD_STATE,</span>
    /**
     * point persisted across the update
     */
<span class="fc" id="L1034">    PERSIST_STATE,</span>
    /**
     * point was removed in the update
     */
<span class="fc" id="L1038">    REMOVE_STATE</span>
  }

  /**
   * This structure is used to keep track of the best separating axis.
   */
<span class="fc" id="L1044">  static class EPAxis {</span>
<span class="fc" id="L1045">    enum Type {</span>
<span class="fc" id="L1046">      UNKNOWN, EDGE_A, EDGE_B</span>
    }

    Type type;
    int index;
    float separation;
  }

  /**
   * This holds polygon B expressed in frame A.
   */
  static class TempPolygon {
<span class="fc" id="L1058">    final Vec2[] vertices = new Vec2[Settings.maxPolygonVertices];</span>
<span class="fc" id="L1059">    final Vec2[] normals = new Vec2[Settings.maxPolygonVertices];</span>
    int count;

<span class="fc" id="L1062">    public TempPolygon() {</span>
<span class="fc bfc" id="L1063" title="All 2 branches covered.">      for (int i = 0; i &lt; vertices.length; i++) {</span>
<span class="fc" id="L1064">        vertices[i] = new Vec2();</span>
<span class="fc" id="L1065">        normals[i] = new Vec2();</span>
      }
<span class="fc" id="L1067">    }</span>
  }

  /**
   * Reference face used for clipping
   */
<span class="fc" id="L1073">  static class ReferenceFace {</span>
    int i1, i2;
<span class="fc" id="L1075">    final Vec2 v1 = new Vec2();</span>
<span class="fc" id="L1076">    final Vec2 v2 = new Vec2();</span>
<span class="fc" id="L1077">    final Vec2 normal = new Vec2();</span>

<span class="fc" id="L1079">    final Vec2 sideNormal1 = new Vec2();</span>
    float sideOffset1;

<span class="fc" id="L1082">    final Vec2 sideNormal2 = new Vec2();</span>
    float sideOffset2;
  }

  /**
   * This class collides and edge and a polygon, taking into account edge adjacency.
   */
  static class EPCollider {
<span class="nc" id="L1090">    enum VertexType {</span>
<span class="nc" id="L1091">      ISOLATED, CONCAVE, CONVEX</span>
    }

<span class="fc" id="L1094">    final TempPolygon m_polygonB = new TempPolygon();</span>

<span class="fc" id="L1096">    final Transform m_xf = new Transform();</span>
<span class="fc" id="L1097">    final Vec2 m_centroidB = new Vec2();</span>
<span class="fc" id="L1098">    Vec2 m_v0 = new Vec2();</span>
<span class="fc" id="L1099">    Vec2 m_v1 = new Vec2();</span>
<span class="fc" id="L1100">    Vec2 m_v2 = new Vec2();</span>
<span class="fc" id="L1101">    Vec2 m_v3 = new Vec2();</span>
<span class="fc" id="L1102">    final Vec2 m_normal0 = new Vec2();</span>
<span class="fc" id="L1103">    final Vec2 m_normal1 = new Vec2();</span>
<span class="fc" id="L1104">    final Vec2 m_normal2 = new Vec2();</span>
<span class="fc" id="L1105">    final Vec2 m_normal = new Vec2();</span>

    VertexType m_type1, m_type2;

<span class="fc" id="L1109">    final Vec2 m_lowerLimit = new Vec2();</span>
<span class="fc" id="L1110">    final Vec2 m_upperLimit = new Vec2();</span>
    float m_radius;
    boolean m_front;

<span class="fc" id="L1114">    public EPCollider() {</span>
<span class="fc bfc" id="L1115" title="All 2 branches covered.">      for (int i = 0; i &lt; 2; i++) {</span>
<span class="fc" id="L1116">        ie[i] = new ClipVertex();</span>
<span class="fc" id="L1117">        clipPoints1[i] = new ClipVertex();</span>
<span class="fc" id="L1118">        clipPoints2[i] = new ClipVertex();</span>
      }
<span class="fc" id="L1120">    }</span>

<span class="fc" id="L1122">    private final Vec2 edge1 = new Vec2();</span>
<span class="fc" id="L1123">    private final Vec2 temp = new Vec2();</span>
<span class="fc" id="L1124">    private final Vec2 edge0 = new Vec2();</span>
<span class="fc" id="L1125">    private final Vec2 edge2 = new Vec2();</span>
<span class="fc" id="L1126">    private final ClipVertex[] ie = new ClipVertex[2];</span>
<span class="fc" id="L1127">    private final ClipVertex[] clipPoints1 = new ClipVertex[2];</span>
<span class="fc" id="L1128">    private final ClipVertex[] clipPoints2 = new ClipVertex[2];</span>
<span class="fc" id="L1129">    private final ReferenceFace rf = new ReferenceFace();</span>
<span class="fc" id="L1130">    private final EPAxis edgeAxis = new EPAxis();</span>
<span class="fc" id="L1131">    private final EPAxis polygonAxis = new EPAxis();</span>

    public void collide(Manifold manifold, final EdgeShape edgeA, final Transform xfA,
        final PolygonShape polygonB, final Transform xfB) {

<span class="fc" id="L1136">      Transform.mulTransToOutUnsafe(xfA, xfB, m_xf);</span>
<span class="fc" id="L1137">      Transform.mulToOutUnsafe(m_xf, polygonB.m_centroid, m_centroidB);</span>

<span class="fc" id="L1139">      m_v0 = edgeA.m_vertex0;</span>
<span class="fc" id="L1140">      m_v1 = edgeA.m_vertex1;</span>
<span class="fc" id="L1141">      m_v2 = edgeA.m_vertex2;</span>
<span class="fc" id="L1142">      m_v3 = edgeA.m_vertex3;</span>

<span class="fc" id="L1144">      boolean hasVertex0 = edgeA.m_hasVertex0;</span>
<span class="fc" id="L1145">      boolean hasVertex3 = edgeA.m_hasVertex3;</span>

<span class="fc" id="L1147">      edge1.set(m_v2).subLocal(m_v1);</span>
<span class="fc" id="L1148">      edge1.normalize();</span>
<span class="fc" id="L1149">      m_normal1.set(edge1.y, -edge1.x);</span>
<span class="fc" id="L1150">      float offset1 = Vec2.dot(m_normal1, temp.set(m_centroidB).subLocal(m_v1));</span>
<span class="fc" id="L1151">      float offset0 = 0.0f, offset2 = 0.0f;</span>
<span class="fc" id="L1152">      boolean convex1 = false, convex2 = false;</span>

      // Is there a preceding edge?
<span class="pc bpc" id="L1155" title="1 of 2 branches missed.">      if (hasVertex0) {</span>
<span class="nc" id="L1156">        edge0.set(m_v1).subLocal(m_v0);</span>
<span class="nc" id="L1157">        edge0.normalize();</span>
<span class="nc" id="L1158">        m_normal0.set(edge0.y, -edge0.x);</span>
<span class="nc bnc" id="L1159" title="All 2 branches missed.">        convex1 = Vec2.cross(edge0, edge1) &gt;= 0.0f;</span>
<span class="nc" id="L1160">        offset0 = Vec2.dot(m_normal0, temp.set(m_centroidB).subLocal(m_v0));</span>
      }

      // Is there a following edge?
<span class="pc bpc" id="L1164" title="1 of 2 branches missed.">      if (hasVertex3) {</span>
<span class="nc" id="L1165">        edge2.set(m_v3).subLocal(m_v2);</span>
<span class="nc" id="L1166">        edge2.normalize();</span>
<span class="nc" id="L1167">        m_normal2.set(edge2.y, -edge2.x);</span>
<span class="nc bnc" id="L1168" title="All 2 branches missed.">        convex2 = Vec2.cross(edge1, edge2) &gt; 0.0f;</span>
<span class="nc" id="L1169">        offset2 = Vec2.dot(m_normal2, temp.set(m_centroidB).subLocal(m_v2));</span>
      }

      // Determine front or back collision. Determine collision normal limits.
<span class="pc bpc" id="L1173" title="3 of 4 branches missed.">      if (hasVertex0 &amp;&amp; hasVertex3) {</span>
<span class="nc bnc" id="L1174" title="All 4 branches missed.">        if (convex1 &amp;&amp; convex2) {</span>
<span class="nc bnc" id="L1175" title="All 6 branches missed.">          m_front = offset0 &gt;= 0.0f || offset1 &gt;= 0.0f || offset2 &gt;= 0.0f;</span>
<span class="nc bnc" id="L1176" title="All 2 branches missed.">          if (m_front) {</span>
<span class="nc" id="L1177">            m_normal.x = m_normal1.x;</span>
<span class="nc" id="L1178">            m_normal.y = m_normal1.y;</span>
<span class="nc" id="L1179">            m_lowerLimit.x = m_normal0.x;</span>
<span class="nc" id="L1180">            m_lowerLimit.y = m_normal0.y;</span>
<span class="nc" id="L1181">            m_upperLimit.x = m_normal2.x;</span>
<span class="nc" id="L1182">            m_upperLimit.y = m_normal2.y;</span>
          } else {
<span class="nc" id="L1184">            m_normal.x = -m_normal1.x;</span>
<span class="nc" id="L1185">            m_normal.y = -m_normal1.y;</span>
<span class="nc" id="L1186">            m_lowerLimit.x = -m_normal1.x;</span>
<span class="nc" id="L1187">            m_lowerLimit.y = -m_normal1.y;</span>
<span class="nc" id="L1188">            m_upperLimit.x = -m_normal1.x;</span>
<span class="nc" id="L1189">            m_upperLimit.y = -m_normal1.y;</span>
          }
<span class="nc bnc" id="L1191" title="All 2 branches missed.">        } else if (convex1) {</span>
<span class="nc bnc" id="L1192" title="All 6 branches missed.">          m_front = offset0 &gt;= 0.0f || (offset1 &gt;= 0.0f &amp;&amp; offset2 &gt;= 0.0f);</span>
<span class="nc bnc" id="L1193" title="All 2 branches missed.">          if (m_front) {</span>
<span class="nc" id="L1194">            m_normal.x = m_normal1.x;</span>
<span class="nc" id="L1195">            m_normal.y = m_normal1.y;</span>
<span class="nc" id="L1196">            m_lowerLimit.x = m_normal0.x;</span>
<span class="nc" id="L1197">            m_lowerLimit.y = m_normal0.y;</span>
<span class="nc" id="L1198">            m_upperLimit.x = m_normal1.x;</span>
<span class="nc" id="L1199">            m_upperLimit.y = m_normal1.y;</span>
          } else {
<span class="nc" id="L1201">            m_normal.x = -m_normal1.x;</span>
<span class="nc" id="L1202">            m_normal.y = -m_normal1.y;</span>
<span class="nc" id="L1203">            m_lowerLimit.x = -m_normal2.x;</span>
<span class="nc" id="L1204">            m_lowerLimit.y = -m_normal2.y;</span>
<span class="nc" id="L1205">            m_upperLimit.x = -m_normal1.x;</span>
<span class="nc" id="L1206">            m_upperLimit.y = -m_normal1.y;</span>
          }
<span class="nc bnc" id="L1208" title="All 2 branches missed.">        } else if (convex2) {</span>
<span class="nc bnc" id="L1209" title="All 6 branches missed.">          m_front = offset2 &gt;= 0.0f || (offset0 &gt;= 0.0f &amp;&amp; offset1 &gt;= 0.0f);</span>
<span class="nc bnc" id="L1210" title="All 2 branches missed.">          if (m_front) {</span>
<span class="nc" id="L1211">            m_normal.x = m_normal1.x;</span>
<span class="nc" id="L1212">            m_normal.y = m_normal1.y;</span>
<span class="nc" id="L1213">            m_lowerLimit.x = m_normal1.x;</span>
<span class="nc" id="L1214">            m_lowerLimit.y = m_normal1.y;</span>
<span class="nc" id="L1215">            m_upperLimit.x = m_normal2.x;</span>
<span class="nc" id="L1216">            m_upperLimit.y = m_normal2.y;</span>
          } else {
<span class="nc" id="L1218">            m_normal.x = -m_normal1.x;</span>
<span class="nc" id="L1219">            m_normal.y = -m_normal1.y;</span>
<span class="nc" id="L1220">            m_lowerLimit.x = -m_normal1.x;</span>
<span class="nc" id="L1221">            m_lowerLimit.y = -m_normal1.y;</span>
<span class="nc" id="L1222">            m_upperLimit.x = -m_normal0.x;</span>
<span class="nc" id="L1223">            m_upperLimit.y = -m_normal0.y;</span>
          }
        } else {
<span class="nc bnc" id="L1226" title="All 6 branches missed.">          m_front = offset0 &gt;= 0.0f &amp;&amp; offset1 &gt;= 0.0f &amp;&amp; offset2 &gt;= 0.0f;</span>
<span class="nc bnc" id="L1227" title="All 2 branches missed.">          if (m_front) {</span>
<span class="nc" id="L1228">            m_normal.x = m_normal1.x;</span>
<span class="nc" id="L1229">            m_normal.y = m_normal1.y;</span>
<span class="nc" id="L1230">            m_lowerLimit.x = m_normal1.x;</span>
<span class="nc" id="L1231">            m_lowerLimit.y = m_normal1.y;</span>
<span class="nc" id="L1232">            m_upperLimit.x = m_normal1.x;</span>
<span class="nc" id="L1233">            m_upperLimit.y = m_normal1.y;</span>
          } else {
<span class="nc" id="L1235">            m_normal.x = -m_normal1.x;</span>
<span class="nc" id="L1236">            m_normal.y = -m_normal1.y;</span>
<span class="nc" id="L1237">            m_lowerLimit.x = -m_normal2.x;</span>
<span class="nc" id="L1238">            m_lowerLimit.y = -m_normal2.y;</span>
<span class="nc" id="L1239">            m_upperLimit.x = -m_normal0.x;</span>
<span class="nc" id="L1240">            m_upperLimit.y = -m_normal0.y;</span>
          }
        }
<span class="pc bpc" id="L1243" title="1 of 2 branches missed.">      } else if (hasVertex0) {</span>
<span class="nc bnc" id="L1244" title="All 2 branches missed.">        if (convex1) {</span>
<span class="nc bnc" id="L1245" title="All 4 branches missed.">          m_front = offset0 &gt;= 0.0f || offset1 &gt;= 0.0f;</span>
<span class="nc bnc" id="L1246" title="All 2 branches missed.">          if (m_front) {</span>
<span class="nc" id="L1247">            m_normal.x = m_normal1.x;</span>
<span class="nc" id="L1248">            m_normal.y = m_normal1.y;</span>
<span class="nc" id="L1249">            m_lowerLimit.x = m_normal0.x;</span>
<span class="nc" id="L1250">            m_lowerLimit.y = m_normal0.y;</span>
<span class="nc" id="L1251">            m_upperLimit.x = -m_normal1.x;</span>
<span class="nc" id="L1252">            m_upperLimit.y = -m_normal1.y;</span>
          } else {
<span class="nc" id="L1254">            m_normal.x = -m_normal1.x;</span>
<span class="nc" id="L1255">            m_normal.y = -m_normal1.y;</span>
<span class="nc" id="L1256">            m_lowerLimit.x = m_normal1.x;</span>
<span class="nc" id="L1257">            m_lowerLimit.y = m_normal1.y;</span>
<span class="nc" id="L1258">            m_upperLimit.x = -m_normal1.x;</span>
<span class="nc" id="L1259">            m_upperLimit.y = -m_normal1.y;</span>
          }
        } else {
<span class="nc bnc" id="L1262" title="All 4 branches missed.">          m_front = offset0 &gt;= 0.0f &amp;&amp; offset1 &gt;= 0.0f;</span>
<span class="nc bnc" id="L1263" title="All 2 branches missed.">          if (m_front) {</span>
<span class="nc" id="L1264">            m_normal.x = m_normal1.x;</span>
<span class="nc" id="L1265">            m_normal.y = m_normal1.y;</span>
<span class="nc" id="L1266">            m_lowerLimit.x = m_normal1.x;</span>
<span class="nc" id="L1267">            m_lowerLimit.y = m_normal1.y;</span>
<span class="nc" id="L1268">            m_upperLimit.x = -m_normal1.x;</span>
<span class="nc" id="L1269">            m_upperLimit.y = -m_normal1.y;</span>
          } else {
<span class="nc" id="L1271">            m_normal.x = -m_normal1.x;</span>
<span class="nc" id="L1272">            m_normal.y = -m_normal1.y;</span>
<span class="nc" id="L1273">            m_lowerLimit.x = m_normal1.x;</span>
<span class="nc" id="L1274">            m_lowerLimit.y = m_normal1.y;</span>
<span class="nc" id="L1275">            m_upperLimit.x = -m_normal0.x;</span>
<span class="nc" id="L1276">            m_upperLimit.y = -m_normal0.y;</span>
          }
        }
<span class="pc bpc" id="L1279" title="1 of 2 branches missed.">      } else if (hasVertex3) {</span>
<span class="nc bnc" id="L1280" title="All 2 branches missed.">        if (convex2) {</span>
<span class="nc bnc" id="L1281" title="All 4 branches missed.">          m_front = offset1 &gt;= 0.0f || offset2 &gt;= 0.0f;</span>
<span class="nc bnc" id="L1282" title="All 2 branches missed.">          if (m_front) {</span>
<span class="nc" id="L1283">            m_normal.x = m_normal1.x;</span>
<span class="nc" id="L1284">            m_normal.y = m_normal1.y;</span>
<span class="nc" id="L1285">            m_lowerLimit.x = -m_normal1.x;</span>
<span class="nc" id="L1286">            m_lowerLimit.y = -m_normal1.y;</span>
<span class="nc" id="L1287">            m_upperLimit.x = m_normal2.x;</span>
<span class="nc" id="L1288">            m_upperLimit.y = m_normal2.y;</span>
          } else {
<span class="nc" id="L1290">            m_normal.x = -m_normal1.x;</span>
<span class="nc" id="L1291">            m_normal.y = -m_normal1.y;</span>
<span class="nc" id="L1292">            m_lowerLimit.x = -m_normal1.x;</span>
<span class="nc" id="L1293">            m_lowerLimit.y = -m_normal1.y;</span>
<span class="nc" id="L1294">            m_upperLimit.x = m_normal1.x;</span>
<span class="nc" id="L1295">            m_upperLimit.y = m_normal1.y;</span>
          }
        } else {
<span class="nc bnc" id="L1298" title="All 4 branches missed.">          m_front = offset1 &gt;= 0.0f &amp;&amp; offset2 &gt;= 0.0f;</span>
<span class="nc bnc" id="L1299" title="All 2 branches missed.">          if (m_front) {</span>
<span class="nc" id="L1300">            m_normal.x = m_normal1.x;</span>
<span class="nc" id="L1301">            m_normal.y = m_normal1.y;</span>
<span class="nc" id="L1302">            m_lowerLimit.x = -m_normal1.x;</span>
<span class="nc" id="L1303">            m_lowerLimit.y = -m_normal1.y;</span>
<span class="nc" id="L1304">            m_upperLimit.x = m_normal1.x;</span>
<span class="nc" id="L1305">            m_upperLimit.y = m_normal1.y;</span>
          } else {
<span class="nc" id="L1307">            m_normal.x = -m_normal1.x;</span>
<span class="nc" id="L1308">            m_normal.y = -m_normal1.y;</span>
<span class="nc" id="L1309">            m_lowerLimit.x = -m_normal2.x;</span>
<span class="nc" id="L1310">            m_lowerLimit.y = -m_normal2.y;</span>
<span class="nc" id="L1311">            m_upperLimit.x = m_normal1.x;</span>
<span class="nc" id="L1312">            m_upperLimit.y = m_normal1.y;</span>
          }
        }
      } else {
<span class="pc bpc" id="L1316" title="1 of 2 branches missed.">        m_front = offset1 &gt;= 0.0f;</span>
<span class="pc bpc" id="L1317" title="1 of 2 branches missed.">        if (m_front) {</span>
<span class="fc" id="L1318">          m_normal.x = m_normal1.x;</span>
<span class="fc" id="L1319">          m_normal.y = m_normal1.y;</span>
<span class="fc" id="L1320">          m_lowerLimit.x = -m_normal1.x;</span>
<span class="fc" id="L1321">          m_lowerLimit.y = -m_normal1.y;</span>
<span class="fc" id="L1322">          m_upperLimit.x = -m_normal1.x;</span>
<span class="fc" id="L1323">          m_upperLimit.y = -m_normal1.y;</span>
        } else {
<span class="nc" id="L1325">          m_normal.x = -m_normal1.x;</span>
<span class="nc" id="L1326">          m_normal.y = -m_normal1.y;</span>
<span class="nc" id="L1327">          m_lowerLimit.x = m_normal1.x;</span>
<span class="nc" id="L1328">          m_lowerLimit.y = m_normal1.y;</span>
<span class="nc" id="L1329">          m_upperLimit.x = m_normal1.x;</span>
<span class="nc" id="L1330">          m_upperLimit.y = m_normal1.y;</span>
        }
      }

      // Get polygonB in frameA
<span class="fc" id="L1335">      m_polygonB.count = polygonB.m_count;</span>
<span class="pc bpc" id="L1336" title="1 of 2 branches missed.">      for (int i = 0; i &lt; polygonB.m_count; ++i) {</span>
<span class="nc" id="L1337">        Transform.mulToOutUnsafe(m_xf, polygonB.m_vertices[i], m_polygonB.vertices[i]);</span>
<span class="nc" id="L1338">        Rot.mulToOutUnsafe(m_xf.q, polygonB.m_normals[i], m_polygonB.normals[i]);</span>
      }

<span class="fc" id="L1341">      m_radius = 2.0f * Settings.polygonRadius;</span>

<span class="fc" id="L1343">      manifold.pointCount = 0;</span>

<span class="fc" id="L1345">      computeEdgeSeparation(edgeAxis);</span>

      // If no valid normal can be found than this edge should not collide.
<span class="pc bpc" id="L1348" title="1 of 2 branches missed.">      if (edgeAxis.type == EPAxis.Type.UNKNOWN) {</span>
<span class="nc" id="L1349">        return;</span>
      }

<span class="pc bpc" id="L1352" title="1 of 2 branches missed.">      if (edgeAxis.separation &gt; m_radius) {</span>
<span class="fc" id="L1353">        return;</span>
      }

<span class="nc" id="L1356">      computePolygonSeparation(polygonAxis);</span>
<span class="nc bnc" id="L1357" title="All 4 branches missed.">      if (polygonAxis.type != EPAxis.Type.UNKNOWN &amp;&amp; polygonAxis.separation &gt; m_radius) {</span>
<span class="nc" id="L1358">        return;</span>
      }

      // Use hysteresis for jitter reduction.
<span class="nc" id="L1362">      final float k_relativeTol = 0.98f;</span>
<span class="nc" id="L1363">      final float k_absoluteTol = 0.001f;</span>

      EPAxis primaryAxis;
<span class="nc bnc" id="L1366" title="All 2 branches missed.">      if (polygonAxis.type == EPAxis.Type.UNKNOWN) {</span>
<span class="nc" id="L1367">        primaryAxis = edgeAxis;</span>
<span class="nc bnc" id="L1368" title="All 2 branches missed.">      } else if (polygonAxis.separation &gt; k_relativeTol * edgeAxis.separation + k_absoluteTol) {</span>
<span class="nc" id="L1369">        primaryAxis = polygonAxis;</span>
      } else {
<span class="nc" id="L1371">        primaryAxis = edgeAxis;</span>
      }

<span class="nc" id="L1374">      final ClipVertex ie0 = ie[0];</span>
<span class="nc" id="L1375">      final ClipVertex ie1 = ie[1];</span>
      
<span class="nc bnc" id="L1377" title="All 2 branches missed.">      if (primaryAxis.type == EPAxis.Type.EDGE_A) {</span>
<span class="nc" id="L1378">        manifold.type = Manifold.ManifoldType.FACE_A;</span>

        // Search for the polygon normal that is most anti-parallel to the edge normal.
<span class="nc" id="L1381">        int bestIndex = 0;</span>
<span class="nc" id="L1382">        float bestValue = Vec2.dot(m_normal, m_polygonB.normals[0]);</span>
<span class="nc bnc" id="L1383" title="All 2 branches missed.">        for (int i = 1; i &lt; m_polygonB.count; ++i) {</span>
<span class="nc" id="L1384">          float value = Vec2.dot(m_normal, m_polygonB.normals[i]);</span>
<span class="nc bnc" id="L1385" title="All 2 branches missed.">          if (value &lt; bestValue) {</span>
<span class="nc" id="L1386">            bestValue = value;</span>
<span class="nc" id="L1387">            bestIndex = i;</span>
          }
        }

<span class="nc" id="L1391">        int i1 = bestIndex;</span>
<span class="nc bnc" id="L1392" title="All 2 branches missed.">        int i2 = i1 + 1 &lt; m_polygonB.count ? i1 + 1 : 0;</span>

<span class="nc" id="L1394">        ie0.v.set(m_polygonB.vertices[i1]);</span>
<span class="nc" id="L1395">        ie0.id.indexA = 0;</span>
<span class="nc" id="L1396">        ie0.id.indexB = (byte) i1;</span>
<span class="nc" id="L1397">        ie0.id.typeA = (byte) ContactID.Type.FACE.ordinal();</span>
<span class="nc" id="L1398">        ie0.id.typeB = (byte) ContactID.Type.VERTEX.ordinal();</span>

<span class="nc" id="L1400">        ie1.v.set(m_polygonB.vertices[i2]);</span>
<span class="nc" id="L1401">        ie1.id.indexA = 0;</span>
<span class="nc" id="L1402">        ie1.id.indexB = (byte) i2;</span>
<span class="nc" id="L1403">        ie1.id.typeA = (byte) ContactID.Type.FACE.ordinal();</span>
<span class="nc" id="L1404">        ie1.id.typeB = (byte) ContactID.Type.VERTEX.ordinal();</span>

<span class="nc bnc" id="L1406" title="All 2 branches missed.">        if (m_front) {</span>
<span class="nc" id="L1407">          rf.i1 = 0;</span>
<span class="nc" id="L1408">          rf.i2 = 1;</span>
<span class="nc" id="L1409">          rf.v1.set(m_v1);</span>
<span class="nc" id="L1410">          rf.v2.set(m_v2);</span>
<span class="nc" id="L1411">          rf.normal.set(m_normal1);</span>
        } else {
<span class="nc" id="L1413">          rf.i1 = 1;</span>
<span class="nc" id="L1414">          rf.i2 = 0;</span>
<span class="nc" id="L1415">          rf.v1.set(m_v2);</span>
<span class="nc" id="L1416">          rf.v2.set(m_v1);</span>
<span class="nc" id="L1417">          rf.normal.set(m_normal1).negateLocal();</span>
        }
<span class="nc" id="L1419">      } else {</span>
<span class="nc" id="L1420">        manifold.type = Manifold.ManifoldType.FACE_B;</span>

<span class="nc" id="L1422">        ie0.v.set(m_v1);</span>
<span class="nc" id="L1423">        ie0.id.indexA = 0;</span>
<span class="nc" id="L1424">        ie0.id.indexB = (byte) primaryAxis.index;</span>
<span class="nc" id="L1425">        ie0.id.typeA = (byte) ContactID.Type.VERTEX.ordinal();</span>
<span class="nc" id="L1426">        ie0.id.typeB = (byte) ContactID.Type.FACE.ordinal();</span>

<span class="nc" id="L1428">        ie1.v.set(m_v2);</span>
<span class="nc" id="L1429">        ie1.id.indexA = 0;</span>
<span class="nc" id="L1430">        ie1.id.indexB = (byte) primaryAxis.index;</span>
<span class="nc" id="L1431">        ie1.id.typeA = (byte) ContactID.Type.VERTEX.ordinal();</span>
<span class="nc" id="L1432">        ie1.id.typeB = (byte) ContactID.Type.FACE.ordinal();</span>

<span class="nc" id="L1434">        rf.i1 = primaryAxis.index;</span>
<span class="nc bnc" id="L1435" title="All 2 branches missed.">        rf.i2 = rf.i1 + 1 &lt; m_polygonB.count ? rf.i1 + 1 : 0;</span>
<span class="nc" id="L1436">        rf.v1.set(m_polygonB.vertices[rf.i1]);</span>
<span class="nc" id="L1437">        rf.v2.set(m_polygonB.vertices[rf.i2]);</span>
<span class="nc" id="L1438">        rf.normal.set(m_polygonB.normals[rf.i1]);</span>
      }

<span class="nc" id="L1441">      rf.sideNormal1.set(rf.normal.y, -rf.normal.x);</span>
<span class="nc" id="L1442">      rf.sideNormal2.set(rf.sideNormal1).negateLocal();</span>
<span class="nc" id="L1443">      rf.sideOffset1 = Vec2.dot(rf.sideNormal1, rf.v1);</span>
<span class="nc" id="L1444">      rf.sideOffset2 = Vec2.dot(rf.sideNormal2, rf.v2);</span>

      // Clip incident edge against extruded edge1 side edges.
      int np;

      // Clip to box side 1
<span class="nc" id="L1450">      np = clipSegmentToLine(clipPoints1, ie, rf.sideNormal1, rf.sideOffset1, rf.i1);</span>

<span class="nc bnc" id="L1452" title="All 2 branches missed.">      if (np &lt; Settings.maxManifoldPoints) {</span>
<span class="nc" id="L1453">        return;</span>
      }

      // Clip to negative box side 1
<span class="nc" id="L1457">      np = clipSegmentToLine(clipPoints2, clipPoints1, rf.sideNormal2, rf.sideOffset2, rf.i2);</span>

<span class="nc bnc" id="L1459" title="All 2 branches missed.">      if (np &lt; Settings.maxManifoldPoints) {</span>
<span class="nc" id="L1460">        return;</span>
      }

      // Now clipPoints2 contains the clipped points.
<span class="nc bnc" id="L1464" title="All 2 branches missed.">      if (primaryAxis.type == EPAxis.Type.EDGE_A) {</span>
<span class="nc" id="L1465">        manifold.localNormal.set(rf.normal);</span>
<span class="nc" id="L1466">        manifold.localPoint.set(rf.v1);</span>
      } else {
<span class="nc" id="L1468">        manifold.localNormal.set(polygonB.m_normals[rf.i1]);</span>
<span class="nc" id="L1469">        manifold.localPoint.set(polygonB.m_vertices[rf.i1]);</span>
      }

<span class="nc" id="L1472">      int pointCount = 0;</span>
<span class="nc bnc" id="L1473" title="All 2 branches missed.">      for (int i = 0; i &lt; Settings.maxManifoldPoints; ++i) {</span>
        float separation;

<span class="nc" id="L1476">        separation = Vec2.dot(rf.normal, temp.set(clipPoints2[i].v).subLocal(rf.v1));</span>

<span class="nc bnc" id="L1478" title="All 2 branches missed.">        if (separation &lt;= m_radius) {</span>
<span class="nc" id="L1479">          ManifoldPoint cp = manifold.points[pointCount];</span>

<span class="nc bnc" id="L1481" title="All 2 branches missed.">          if (primaryAxis.type == EPAxis.Type.EDGE_A) {</span>
            // cp.localPoint = MulT(m_xf, clipPoints2[i].v);
<span class="nc" id="L1483">            Transform.mulTransToOutUnsafe(m_xf, clipPoints2[i].v, cp.localPoint);</span>
<span class="nc" id="L1484">            cp.id.set(clipPoints2[i].id);</span>
          } else {
<span class="nc" id="L1486">            cp.localPoint.set(clipPoints2[i].v);</span>
<span class="nc" id="L1487">            cp.id.typeA = clipPoints2[i].id.typeB;</span>
<span class="nc" id="L1488">            cp.id.typeB = clipPoints2[i].id.typeA;</span>
<span class="nc" id="L1489">            cp.id.indexA = clipPoints2[i].id.indexB;</span>
<span class="nc" id="L1490">            cp.id.indexB = clipPoints2[i].id.indexA;</span>
          }

<span class="nc" id="L1493">          ++pointCount;</span>
        }
      }

<span class="nc" id="L1497">      manifold.pointCount = pointCount;</span>
<span class="nc" id="L1498">    }</span>


    public void computeEdgeSeparation(EPAxis axis) {
<span class="fc" id="L1502">      axis.type = EPAxis.Type.EDGE_A;</span>
<span class="pc bpc" id="L1503" title="1 of 2 branches missed.">      axis.index = m_front ? 0 : 1;</span>
<span class="fc" id="L1504">      axis.separation = Float.MAX_VALUE;</span>
<span class="fc" id="L1505">      float nx = m_normal.x;</span>
<span class="fc" id="L1506">      float ny = m_normal.y;</span>

<span class="pc bpc" id="L1508" title="1 of 2 branches missed.">      for (int i = 0; i &lt; m_polygonB.count; ++i) {</span>
<span class="nc" id="L1509">        Vec2 v = m_polygonB.vertices[i];</span>
<span class="nc" id="L1510">        float tempx = v.x - m_v1.x;</span>
<span class="nc" id="L1511">        float tempy = v.y - m_v1.y;</span>
<span class="nc" id="L1512">        float s = nx * tempx + ny * tempy;</span>
<span class="nc bnc" id="L1513" title="All 2 branches missed.">        if (s &lt; axis.separation) {</span>
<span class="nc" id="L1514">          axis.separation = s;</span>
        }
      }
<span class="fc" id="L1517">    }</span>

<span class="fc" id="L1519">    private final Vec2 perp = new Vec2();</span>
<span class="fc" id="L1520">    private final Vec2 n = new Vec2();</span>

    public void computePolygonSeparation(EPAxis axis) {
<span class="nc" id="L1523">      axis.type = EPAxis.Type.UNKNOWN;</span>
<span class="nc" id="L1524">      axis.index = -1;</span>
<span class="nc" id="L1525">      axis.separation = -Float.MAX_VALUE;</span>
      
<span class="nc" id="L1527">      perp.x = -m_normal.y;</span>
<span class="nc" id="L1528">      perp.y = m_normal.x;</span>

<span class="nc bnc" id="L1530" title="All 2 branches missed.">      for (int i = 0; i &lt; m_polygonB.count; ++i) {</span>
<span class="nc" id="L1531">        Vec2 normalB = m_polygonB.normals[i];</span>
<span class="nc" id="L1532">        Vec2 vB = m_polygonB.vertices[i];</span>
<span class="nc" id="L1533">        n.x = -normalB.x;</span>
<span class="nc" id="L1534">        n.y = -normalB.y;</span>

        // float s1 = Vec2.dot(n, temp.set(vB).subLocal(m_v1));
        // float s2 = Vec2.dot(n, temp.set(vB).subLocal(m_v2));
<span class="nc" id="L1538">        float tempx = vB.x - m_v1.x;</span>
<span class="nc" id="L1539">        float tempy = vB.y - m_v1.y;</span>
<span class="nc" id="L1540">        float s1 = n.x * tempx + n.y * tempy;</span>
<span class="nc" id="L1541">        tempx = vB.x - m_v2.x;</span>
<span class="nc" id="L1542">        tempy = vB.y - m_v2.y;</span>
<span class="nc" id="L1543">        float s2 = n.x * tempx + n.y * tempy;</span>
<span class="nc" id="L1544">        float s = MathUtils.min(s1, s2);</span>

<span class="nc bnc" id="L1546" title="All 2 branches missed.">        if (s &gt; m_radius) {</span>
          // No collision
<span class="nc" id="L1548">          axis.type = EPAxis.Type.EDGE_B;</span>
<span class="nc" id="L1549">          axis.index = i;</span>
<span class="nc" id="L1550">          axis.separation = s;</span>
<span class="nc" id="L1551">          return;</span>
        }

        // Adjacency
<span class="nc bnc" id="L1555" title="All 2 branches missed.">        if (n.x * perp.x + n.y * perp.y &gt;= 0.0f) {</span>
<span class="nc bnc" id="L1556" title="All 2 branches missed.">          if (Vec2.dot(temp.set(n).subLocal(m_upperLimit), m_normal) &lt; -Settings.angularSlop) {</span>
<span class="nc" id="L1557">            continue;</span>
          }
        } else {
<span class="nc bnc" id="L1560" title="All 2 branches missed.">          if (Vec2.dot(temp.set(n).subLocal(m_lowerLimit), m_normal) &lt; -Settings.angularSlop) {</span>
<span class="nc" id="L1561">            continue;</span>
          }
        }

<span class="nc bnc" id="L1565" title="All 2 branches missed.">        if (s &gt; axis.separation) {</span>
<span class="nc" id="L1566">          axis.type = EPAxis.Type.EDGE_B;</span>
<span class="nc" id="L1567">          axis.index = i;</span>
<span class="nc" id="L1568">          axis.separation = s;</span>
        }
      }
<span class="nc" id="L1571">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>